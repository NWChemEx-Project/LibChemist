<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vector Space Design &mdash; Chemist v1.2.5 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/tabs.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=cd41d21b"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Reference Space Design" href="reference_space.html" />
    <link rel="prev" title="Architecture of Wavefunction Component" href="architecture.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html">
            
              <img src="../../../_static/logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                v1.2.5
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing Chemist</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../background/index.html">Chemist Background</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Developer Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Design Documentation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../architecture.html">Architecture of Chemist</a></li>
<li class="toctree-l3"><a class="reference internal" href="../chemical_system/index.html">Design of the Chemical System Component</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ao_basis_set/index.html">Design of the AO Basis Set Component</a></li>
<li class="toctree-l3"><a class="reference internal" href="../topology/index.html">Design of the Topology Component</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fragmenting/index.html">Design of the Fragmenting Component</a></li>
<li class="toctree-l3"><a class="reference internal" href="../operator/index.html">Design of the Operator Component</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Design of the Wavefunction Component</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="architecture.html">Architecture of Wavefunction Component</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Vector Space Design</a></li>
<li class="toctree-l4"><a class="reference internal" href="reference_space.html">Reference Space Design</a></li>
<li class="toctree-l4"><a class="reference internal" href="wavefunction.html">Wavefunction Design</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../developing_the_chemical_system_component.html">Developing the Chemical System Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../writing_views.html">Creating a New View</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../the_traits_component.html">Understanding the Traits Component</a></li>
<li class="toctree-l2"><a class="reference external" href="https://nwchemex.github.io/.github/">NWChemEx author documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Chemist Tutorials</a></li>
<li class="toctree-l1"><a class="reference external" href="https://nwchemex.github.io/Chemist/chemist_cxx_api/index.html">C++ API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Chemist</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Developer Documentation</a></li>
          <li class="breadcrumb-item"><a href="../index.html">Design Documentation</a></li>
          <li class="breadcrumb-item"><a href="index.html">Design of the Wavefunction Component</a></li>
      <li class="breadcrumb-item active">Vector Space Design</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/developer/design/wavefunction/vector_spaces.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="vector-space-design">
<span id="vsd-design"></span><h1>Vector Space Design<a class="headerlink" href="#vector-space-design" title="Link to this heading"></a></h1>
<p>This page documents the design of the vector space component of Chemist. In
practice this component really focuses in on the basis set defining the vector
space; however, in quantum chemistry the term “basis set” is usually associated
specifically with quantities like <cite>6-31G*</cite> and we wish to avoid confusion.</p>
<section id="what-are-vector-spaces">
<h2>What are vector spaces?<a class="headerlink" href="#what-are-vector-spaces" title="Link to this heading"></a></h2>
<p>One can find mathematical descriptions of a vector space
<a class="reference external" href="https://en.wikipedia.org/wiki/Vector_space">here</a>. For our purposes, what
we really care about is that in order to practically represent vectors in a
given vector space one needs to define a basis set.</p>
</section>
<section id="why-do-we-need-vector-spaces">
<h2>Why do we need vector spaces?<a class="headerlink" href="#why-do-we-need-vector-spaces" title="Link to this heading"></a></h2>
<p>Quantum chemistry equations are tensorial in nature. To actually compute
quantities we need tensor representations (<em>i.e.</em>, arrays of numbers). Forming
a tensor representation requires us to pick a basis set (in the general sense,
<em>i.e.</em>, we are not limiting ourselves to things like <cite>6-31G*</cite>). For a given
vector space there are usually an infinite number of basis sets, and
unfortunately each (in general) results in a different tensor representation.
The point being, in order to programatically express which basis set we are
using, we need a class (or series of classes) to convey this information.</p>
</section>
<section id="vector-space-considerations">
<span id="vsd-considerations"></span><h2>Vector Space Considerations<a class="headerlink" href="#vector-space-considerations" title="Link to this heading"></a></h2>
<p>The following lists the considerations which went into designing the vector
space component of Chemist:</p>
<dl class="simple" id="vsd-basis-set">
<dt>Basis Set</dt><dd><p>In practice, we’re really designing basis sets (all of which can be used
to define vector spaces, but that’s not really what we care about). The
vector space component needs to support arbitrary basis functions, not just
basis functions which are orbitals. Notable examples:</p>
<ul class="simple">
<li><p>Cartesian axes</p></li>
<li><p>Spin</p></li>
</ul>
</dd>
</dl>
<dl class="simple" id="vsd-parameters">
<dt>Parameters</dt><dd><p>Basis sets have different basis functions, we need a means of telling the
basis functions a part. Typically this is done by referring to the
parameter values for a particular basis function. Parameters come in a
variety of types:</p>
<ul class="simple">
<li><p>Implicit. Usually defined by conventional labels, <em>e.g</em>, the “x”-axis of a
Cartesian basis set, or the <span class="math notranslate nohighlight">\(\alpha\)</span> spin function.</p></li>
<li><p>Explicit. Many basis functions are defined by explicit numeric parameters,
<em>e.g.</em>, primitive Gaussian functions, or plane waves.</p></li>
<li><p>Mix of implicit and explicit. These are basis functions which are defined
in terms of both implicit and explicit parameters, <em>e.g.</em>, spin orbitals,
or the basis set for dipole moment integrals.</p></li>
<li><p>Transformation from another basis set, <em>e.g.</em>,
contracted Gaussian type orbitals, or molecular orbitals.</p></li>
</ul>
</dd>
</dl>
<dl class="simple" id="vsd-properties">
<dt>Properties</dt><dd><p>Basis sets are usually not chosen at random. Rather, one typically chooses a
basis set which satisfies a particular property. Notable examples
include:</p>
<ul class="simple">
<li><p>Canonical molecular orbitals, which diagonalize the Fock matrix.</p></li>
<li><p>Natural molecular orbitals, which  diagonalize the one-electron density
matrix.</p></li>
<li><p>Independent/dependent orbitals which have a sparse map relationship.</p></li>
</ul>
</dd>
</dl>
<dl class="simple" id="vsd-type-dispatch">
<dt>Type Dispatch</dt><dd><p>Programatically the vector spaces will be used to construct property types.
The types for the vector space should aim for generality, while still
containing sufficient information to ensure that a property type can only
be called with vector spaces possessing the correct properties. Examples:</p>
<ul class="simple">
<li><p>If an algorithm assumes that the provided orbitals are canonical
molecular orbitals, we in general do not want to call such an algorithm
with localized orbitals.</p></li>
</ul>
</dd>
</dl>
<dl class="simple" id="vsd-generalization">
<dt>Generalization Reflected in Inheritance</dt><dd><p>We have also striven to ensure that the class hierarchy is defined in such
a way that derived classes can be used with algorithms designed for base
classes. For example:</p>
<ul class="simple">
<li><p>In theory, it is possible to use restricted molecular orbitals with an
unrestricted algorithm (the spins just have the same orbitals). While this
has performance consequences (you’re doing the same operation multiple
times). It can be useful if, for example, a restricted algorithm has not
yet been implemented</p></li>
</ul>
</dd>
</dl>
</section>
<section id="id1">
<h2>Vector Space Design<a class="headerlink" href="#id1" title="Link to this heading"></a></h2>
<p>The design of the vector space component is based primarily on the
considerations listed in section <a class="reference internal" href="#vsd-considerations"><span class="std std-ref">Vector Space Considerations</span></a>. The vector space
component of Chemist contains a lot of classes, this is necessary to
satisfy the <a class="reference internal" href="#vsd-type-dispatch"><span class="std std-ref">Type Dispatch</span></a> consideration. That said, terminology
already existed prior to our design for the distinctions, suggesting that the
distinctions among the classes are physical in nature.</p>
<section id="fundamental-classes">
<h3>Fundamental Classes<a class="headerlink" href="#fundamental-classes" title="Link to this heading"></a></h3>
<figure class="align-center" id="id2">
<span id="fig-fundamental-spaces"></span><img alt="../../../_images/fundamental_spaces.png" src="../../../_images/fundamental_spaces.png" />
<figcaption>
<p><span class="caption-number">Fig. 16 </span><span class="caption-text">The fundamental classes comprising Chemist’s vector space component. The
vector space component is envisioned as having many classes, but the heavy
lifting is done by these “fundamental” classes.</span><a class="headerlink" href="#id2" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#fig-fundamental-spaces"><span class="std std-numref">Fig. 16</span></a> shows the design of classes fundamental to the
vector space component of Chemist. The fundamental classes try to distill the
fundamental properties of the various spaces down to “properties”. The spaces
we know and love then become more-or-less strong types to distinguish among the
more esoteric differences.</p>
<section id="base-class">
<h4>Base Class<a class="headerlink" href="#base-class" title="Link to this heading"></a></h4>
<p>At the base of the class hierarchy is the <code class="docutils literal notranslate"><span class="pre">BaseSpace</span></code> class. This class is
primarily meant to provide code factorization for the derived classes. It is
also useful in a few places where we try to write very generic algorithms
(<em>e.g.</em>, for transforming tensors).</p>
</section>
<section id="cartesian-space">
<h4>Cartesian Space<a class="headerlink" href="#cartesian-space" title="Link to this heading"></a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">CartesianSpace</span></code> class is meant to represent <span class="math notranslate nohighlight">\(N\)</span>-dimensional
Cartesian space, <em>i.e.</em>, <span class="math notranslate nohighlight">\(\mathbb{R}^N\)</span>. In practice, this class’s only
state is the value of <span class="math notranslate nohighlight">\(N\)</span>. The need for <code class="docutils literal notranslate"><span class="pre">CartesianSpace</span></code> stems from
Consideration <a class="reference internal" href="#vsd-basis-set"><span class="std std-ref">Basis Set</span></a>.</p>
</section>
<section id="spin-space">
<h4>Spin Space<a class="headerlink" href="#spin-space" title="Link to this heading"></a></h4>
<p>Conceptually similar to <code class="docutils literal notranslate"><span class="pre">CartesianSpace</span></code>, the <code class="docutils literal notranslate"><span class="pre">SpinSpace</span></code> class represents
the space spanned by a series of spin functions. In the most common scenario,
an instance of <code class="docutils literal notranslate"><span class="pre">SpinSpace</span></code> represents the spins of an electron and thus
contains two functions. State of the <code class="docutils literal notranslate"><span class="pre">SpinSpace</span></code> class is the total spin,
which would be 1/2 for an electron. The need for this class also stems from
consideration <a class="reference internal" href="#vsd-basis-set"><span class="std std-ref">Basis Set</span></a>.</p>
</section>
<section id="atomic-orbitals-aos">
<h4>Atomic Orbitals (AOs)<a class="headerlink" href="#atomic-orbitals-aos" title="Link to this heading"></a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">AOSpace</span></code> represents the space spanned by the atomic orbitals which can
be generated from the molecular basis set (here basis set is used in the
computational chemistry sense). The <code class="docutils literal notranslate"><span class="pre">AOSpace</span></code> is a very important space for
most calculations because it represents a sort of “most fundamental space”
from which all other orbital spaces are usually derived. The need for the
<code class="docutils literal notranslate"><span class="pre">AOSpace</span></code> class primarily stems from consideration <a class="reference internal" href="#vsd-parameters"><span class="std std-ref">Parameters</span></a>.</p>
<p>It is worth noting that in practice what we call AOs are often transformed,
contracted Gaussian type orbitals. In theory we could better consolidate the
<code class="docutils literal notranslate"><span class="pre">AOBasisSet</span></code> class (which describes the parameters associated with those
orbitals) with the various vector space classes by defining:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PrimitiveGaussianSpace</span></code> holds the centers, angular momenta, and exponents
for each primitive (Cartesian) Gaussian function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CGTOSpace=TransformedSpace&lt;T,</span> <span class="pre">PrimitiveGaussianSpace&gt;</span></code> stores the
contraction coefficients for going from primitive Gaussians to contracted
(Cartesian) Gaussian type orbitals.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SphericalGTOSpace</span> <span class="pre">=</span> <span class="pre">TransformedSpace&lt;T,</span> <span class="pre">CGTOSpace&gt;</span></code> holds the spherical
transform for going from contracted (Cartesian) Gaussian type orbitals to
spherical Gaussian type orbitals.</p></li>
</ul>
<p>That said, most electronic structure packages have a class/concept similar to
our <code class="docutils literal notranslate"><span class="pre">AOBasisSet</span></code> class and thus inter-package interoperability is facilitated
by having an <code class="docutils literal notranslate"><span class="pre">AOBasisSet</span></code> class. Nonetheless, there are still use cases which
could benefit from deviating from the standard <code class="docutils literal notranslate"><span class="pre">AOBasisSet</span></code> concepts, <em>e.g.</em>,
relativistic calculations which typically un-contract the contracted Gaussians.
It may be worth revisiting the design of the <code class="docutils literal notranslate"><span class="pre">AOBasisSet</span></code> class if one is
interested in use cases which use more fundamental orbitals than the ones
represented by the <code class="docutils literal notranslate"><span class="pre">AOSpace</span></code>.</p>
</section>
<section id="derived-space">
<h4>Derived Space<a class="headerlink" href="#derived-space" title="Link to this heading"></a></h4>
<p>Many of the spaces we are interested in our defined as linear transformations
of one another. The <code class="docutils literal notranslate"><span class="pre">DerivedSpace&lt;T,R&gt;</span></code> class represents a space obtained by
transforming a space of type <code class="docutils literal notranslate"><span class="pre">R</span></code> (<code class="docutils literal notranslate"><span class="pre">R</span></code> is typically <code class="docutils literal notranslate"><span class="pre">AOSpace</span></code>) by a
transformation of type <code class="docutils literal notranslate"><span class="pre">T</span></code> (<code class="docutils literal notranslate"><span class="pre">T</span></code> is a tensor-like type). Usually the
transformation is a rotation (meaning it preserves lengths and angles of the
space being transformed), but we don’t strictly enforce this (one could). In
practice, the <code class="docutils literal notranslate"><span class="pre">DerivedSpace&lt;T,</span> <span class="pre">R&gt;</span></code> class primarily serves as code
factorization for the variety of spaces which are defined as linear
transformations; by introducing <code class="docutils literal notranslate"><span class="pre">DerivedSpace&lt;T,</span> <span class="pre">R&gt;</span></code>, many of those spaces
are simply strong types.</p>
</section>
<section id="product-space">
<h4>Product Space<a class="headerlink" href="#product-space" title="Link to this heading"></a></h4>
<p>There are several important vector spaces which are obtained by taking tensor
products of other spaces. The <code class="docutils literal notranslate"><span class="pre">ProductSpace&lt;R...&gt;</span></code> class represents a
space resulting from the product of the spaces <code class="docutils literal notranslate"><span class="pre">R...</span></code> (assumed to be two or
more other spaces). Like <code class="docutils literal notranslate"><span class="pre">DerivedSpace&lt;T,</span> <span class="pre">R&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">ProductSpace&lt;R...&gt;`</span></code> is
introduced as a means of code factorization so that the derived classes
become strong types.</p>
</section>
<section id="natural-space">
<h4>Natural Space<a class="headerlink" href="#natural-space" title="Link to this heading"></a></h4>
<p>There are a number of orbital spaces where the transformation is defined by
requiring the resulting orbitals to diagonalize a particular tensor. In these
cases the resulting orbitals are often said to be the “natural” basis set on
account of the fact that they simplify equations involving the diagonalized
quantity. Compared to a <code class="docutils literal notranslate"><span class="pre">DerivedSpace&lt;T,</span> <span class="pre">R&gt;</span></code> object, the additional state
contained in a <code class="docutils literal notranslate"><span class="pre">NaturalSpace&lt;T,</span> <span class="pre">B&gt;</span></code> is the diagonalized tensor (which is
assumed to be stored in a tensor of type <code class="docutils literal notranslate"><span class="pre">T</span></code>). Rather than deriving directly
from <code class="docutils literal notranslate"><span class="pre">DerivedSpace&lt;T,R&gt;</span></code> we allow the user to specify the base class to
derive from, this allows it to be used with a variety of the orbital space
classes defined below. The need for this space  stems from the
<a class="reference internal" href="#vsd-properties"><span class="std std-ref">Properties</span></a> consideration.</p>
</section>
<section id="localized-space">
<h4>Localized Space<a class="headerlink" href="#localized-space" title="Link to this heading"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">LocalizedSpace&lt;B&gt;</span></code> is a strong type used to denote that the orbitals have
been spatially localized according to some metric. At present we do not
discern what that metric is. Like <code class="docutils literal notranslate"><span class="pre">NaturalSpace&lt;T,B&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">LocalizedSpace&lt;B&gt;</span></code>
is templated on the class it derives from so that it can be used with any of
the orbital space classes below.</p>
</section>
<section id="independent-spaces">
<h4>Independent Spaces<a class="headerlink" href="#independent-spaces" title="Link to this heading"></a></h4>
<p>In theories exploiting (usually spatial) sparsity, members of one basis
set usually only have non-zero tensor elements with some of the members of
another basis set. This defines a “sparse map” where each member of the first
basis set is associated with a “domain” of the second set. The first set
is termed the “independent space” and the second basis set is termed the
“dependent space”. The <code class="docutils literal notranslate"><span class="pre">IndependentSpace&lt;B&gt;</span></code> class serves as
code-factorization for implementing vector spaces for which we have sparse
maps. Relative to the base class <code class="docutils literal notranslate"><span class="pre">B</span></code> it inherits from,
<code class="docutils literal notranslate"><span class="pre">IndependentSpace&lt;B&gt;</span></code> includes a sparse map.</p>
</section>
</section>
<section id="orbital-space-classes">
<h3>Orbital Space Classes<a class="headerlink" href="#orbital-space-classes" title="Link to this heading"></a></h3>
<p>While the fundamental classes represent the quintessential properties vector
spaces may have from a program stand point, chemists are more used to
thinking in terms of named spaces like molecular orbitals, or localized
molecular orbitals. The various orbital space classes described in this section
represent those named spaces.</p>
<figure class="align-center" id="id3">
<span id="fig-orbital-spaces"></span><img alt="../../../_images/orbital_spaces.png" src="../../../_images/orbital_spaces.png" />
<figcaption>
<p><span class="caption-number">Fig. 17 </span><span class="caption-text">The named orbital spaces residing in Chemist’s vector space component.</span><a class="headerlink" href="#id3" title="Link to this image"></a></p>
</figcaption>
</figure>
<section id="atomic-spin-orbital-aso-space">
<h4>Atomic Spin Orbital (ASO) Space<a class="headerlink" href="#atomic-spin-orbital-aso-space" title="Link to this heading"></a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">ASOSpace</span></code> is a strong type for the product space formed from combining
AOs and spin functions. AFAIU, ASOs are the starting point for most theory
formulations assuming atom-centered basis functions. The actual <code class="docutils literal notranslate"><span class="pre">ASOSpace</span></code>
class is envisioned to be more of an actionable typedef than anything else.</p>
</section>
<section id="spinor-space">
<h4>Spinor Space<a class="headerlink" href="#spinor-space" title="Link to this heading"></a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">SpinorSpace&lt;T&gt;</span></code> class is a strong type of a derived space whose
reference state is comprised of ASOs. For <span class="math notranslate nohighlight">\(N\)</span> AOs this means we have <span class="math notranslate nohighlight">\(2N\)</span> ASOs,
which get transformed into <span class="math notranslate nohighlight">\(2N\)</span> spinors. In turn the we have a <span class="math notranslate nohighlight">\(2N\)</span> by <span class="math notranslate nohighlight">\(2N\)</span>
transformation matrix.</p>
</section>
<section id="molecular-spin-orbitals-msos">
<h4>Molecular Spin Orbitals (MSOs)<a class="headerlink" href="#molecular-spin-orbitals-msos" title="Link to this heading"></a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">MSOSpace&lt;T&gt;</span></code> differs from the <code class="docutils literal notranslate"><span class="pre">SpinorSpace&lt;T&gt;</span></code> in that the orbital
transformation is restricted so that the <span class="math notranslate nohighlight">\(\alpha\)</span> ASOs are only mixed with
other <span class="math notranslate nohighlight">\(\alpha\)</span> ASOs and the <span class="math notranslate nohighlight">\(\beta\)</span> ASOs are only mixed with other <span class="math notranslate nohighlight">\(\beta\)</span> ASOs`.
In turn, each of the resulting <span class="math notranslate nohighlight">\(2N\)</span> MSOs are defined in terms of <span class="math notranslate nohighlight">\(N\)</span>
coefficients and our transformation is <span class="math notranslate nohighlight">\(N\)</span> by <span class="math notranslate nohighlight">\(2N\)</span>, not <span class="math notranslate nohighlight">\(2N\)</span> by <span class="math notranslate nohighlight">\(2N\)</span> like
<code class="docutils literal notranslate"><span class="pre">SpinorSpace&lt;T&gt;</span></code>. The inheritance of MSOs from spinors satisfies the
<a class="reference internal" href="#vsd-generalization"><span class="std std-ref">Generalization Reflected in Inheritance</span></a> consideration, since MSOs are just spinors with
zeroed out mixed spin blocks.</p>
</section>
<section id="molecular-orbitals-mos">
<h4>Molecular Orbitals (MOs)<a class="headerlink" href="#molecular-orbitals-mos" title="Link to this heading"></a></h4>
<p>Restricting the <code class="docutils literal notranslate"><span class="pre">MSOSpace&lt;T&gt;</span></code> transformation coefficients so that the <span class="math notranslate nohighlight">\(\alpha\)</span>
and <span class="math notranslate nohighlight">\(\beta\)</span> MSOs have the same coefficients leads to an <span class="math notranslate nohighlight">\(N\)</span> by <span class="math notranslate nohighlight">\(N\)</span>
transformation matrix. The assumption is captured by defining the <code class="docutils literal notranslate"><span class="pre">MOSpace&lt;T&gt;</span></code>
strong type. Inheritance here is consistent with the fact that MOs can be
used with MSO algorithms by using the same transformation coefficients for both
the <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> MSOs.</p>
</section>
<section id="canonical-molecular-orbitals-cmos">
<h4>Canonical Molecular Orbitals (CMOs)<a class="headerlink" href="#canonical-molecular-orbitals-cmos" title="Link to this heading"></a></h4>
<p>In conventional electronic structure theory, the CMOs, <em>i.e.</em>,  the orbitals
which diagonalize the Fock matrix, are one of the most important natural
spaces on account of the fact that they simplify the derivation of
correlated methods. The <code class="docutils literal notranslate"><span class="pre">CMOSpace&lt;T&gt;</span></code> class is a strong type to denote
that the additional tensor contained in the base
<code class="docutils literal notranslate"><span class="pre">NaturalSpace&lt;T,</span> <span class="pre">MOSpace&lt;T&gt;&gt;</span></code> object contains the orbital energies and that
the orbitals diagonalize the Fock matrix.</p>
</section>
<section id="natural-orbitals-nos">
<h4>Natural Orbitals (NOs)<a class="headerlink" href="#natural-orbitals-nos" title="Link to this heading"></a></h4>
<p>NOs diagonalize the one-electron density matrix and the <code class="docutils literal notranslate"><span class="pre">NOSpace&lt;T&gt;</span></code> class
denotes this property by being a strong type derived from
<code class="docutils literal notranslate"><span class="pre">NaturalSpace&lt;T,</span> <span class="pre">MOSpace&lt;T&gt;&gt;</span></code>. The additional tensor residing in the
<code class="docutils literal notranslate"><span class="pre">NaturalSpace&lt;T,</span> <span class="pre">MOSpace&lt;T&gt;&gt;</span></code> object holds the orbital occupation values.</p>
</section>
<section id="notes-on-side-casts">
<h4>Notes on “Side Casts”<a class="headerlink" href="#notes-on-side-casts" title="Link to this heading"></a></h4>
<p>The design of the class hierarchy relies on single inheritance. This raises
some conceptual problems, for example, <code class="docutils literal notranslate"><span class="pre">MOSpace&lt;T&gt;</span></code> is also a type of
<code class="docutils literal notranslate"><span class="pre">DerivedSpace&lt;T,</span> <span class="pre">AOSpace&gt;</span></code> (note it is <code class="docutils literal notranslate"><span class="pre">AOSpace</span></code> NOT <code class="docutils literal notranslate"><span class="pre">ASOSpace</span></code>) and
therefore it should be possible to pass an <code class="docutils literal notranslate"><span class="pre">MOSpace&lt;T&gt;</span></code> object to a function
expecting a <code class="docutils literal notranslate"><span class="pre">DerivedSpace&lt;T,</span> <span class="pre">AOSpace&gt;</span></code> object (consistent with the
<a class="reference internal" href="#vsd-generalization"><span class="std std-ref">Generalization Reflected in Inheritance</span></a> consideration). There are at least two possible
solutions: introduce multiple inheritance (<em>i.e.</em>, also derive <code class="docutils literal notranslate"><span class="pre">MOSpace&lt;T&gt;</span></code>
from <code class="docutils literal notranslate"><span class="pre">DerivedSpace&lt;T,</span> <span class="pre">AOSpace&gt;</span></code>) or rely on implicit conversions. Owing to
the complexities of writing class hierarchies with multiple inheritance we
have opted for the latter.</p>
</section>
</section>
</section>
<section id="vector-space-summary">
<h2>Vector Space Summary<a class="headerlink" href="#vector-space-summary" title="Link to this heading"></a></h2>
<p>Over the years, electronic structure theorists have used a lot of basis sets.
Each basis set has different properties, which in turn can influence the
approximations and assumptions algorithms consuming the basis sets can make.
The vector space component was introduced to represent those basis set in the
simplest manner possible. The vector space component was designed adhering to
the considerations listed in <a class="reference internal" href="#vsd-considerations"><span class="std std-ref">Vector Space Considerations</span></a>. The responsiveness of
our design to those considerations is summarized below.</p>
<dl class="simple">
<dt><a class="reference internal" href="#vsd-basis-set"><span class="std std-ref">Basis Set</span></a></dt><dd><p>The design includes a number of non-orbital vector spaces and the
<code class="docutils literal notranslate"><span class="pre">BaseSpace</span></code> class does not assume that classes which derives from it
actually contain orbitals.</p>
</dd>
<dt><a class="reference internal" href="#vsd-parameters"><span class="std std-ref">Parameters</span></a></dt><dd><p>The class hierarchy derives a new class anytime the definition of the
basis set depends on a new set of parameters.</p>
</dd>
<dt><a class="reference internal" href="#vsd-properties"><span class="std std-ref">Properties</span></a></dt><dd><p>Classes representing generic (and specific) basis set properties are found
throughout the hierarchy. Functions are encouraged to use the lowest level
(<em>i.e.</em>, closest to <code class="docutils literal notranslate"><span class="pre">BaseSpace</span></code>) necessary in order to implement their
algorithm.</p>
</dd>
<dt><a class="reference internal" href="#vsd-type-dispatch"><span class="std std-ref">Type Dispatch</span></a></dt><dd><p>Ultimately similar to <a class="reference internal" href="#vsd-properties"><span class="std std-ref">Properties</span></a>, by establishing a series of
strong types throughout the hierarchy it is possible to distinguish between,
say canonical molecular orbitals and natural orbitals by type alone. In
turn, if a module, for example, wants to assume it has been provided CMOs,
it can do so by relying on C++’s type system.</p>
</dd>
<dt><a class="reference internal" href="#vsd-generalization"><span class="std std-ref">Generalization Reflected in Inheritance</span></a></dt><dd><p>The inheritance of the orbital spaces was designed to reflect how the
various electronic structure theories generalize with respect to spin.
Developers of the classes are encouraged to implement whatever implicit
conversions make sense in order to simulate a multiple-inheritance
hierarchy.</p>
</dd>
</dl>
</section>
<section id="future-considerations">
<h2>Future Considerations<a class="headerlink" href="#future-considerations" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">IndependentSpace&lt;B&gt;</span></code> class is envisioned as being used by a whole
host of additional spaces. The design should be fleshed out to accommodate
those spaces when the time comes.</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="architecture.html" class="btn btn-neutral float-left" title="Architecture of Wavefunction Component" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="reference_space.html" class="btn btn-neutral float-right" title="Reference Space Design" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, NWChemEx Community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>