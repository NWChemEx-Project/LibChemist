<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>chemist: chemist::tensor::SparseShape&lt; FieldType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">chemist
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacechemist.html">chemist</a></li><li class="navelem"><b>tensor</b></li><li class="navelem"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html">SparseShape</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classchemist_1_1tensor_1_1SparseShape-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">chemist::tensor::SparseShape&lt; FieldType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Describes a tensor's shape when there's sparsity.  
 <a href="classchemist_1_1tensor_1_1SparseShape.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sparse__shape_8hpp_source.html">sparse_shape.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for chemist::tensor::SparseShape&lt; FieldType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classchemist_1_1tensor_1_1SparseShape.png" usemap="#chemist::tensor::SparseShape_3C_20FieldType_20_3E_map" alt=""/>
  <map id="chemist::tensor::SparseShape_3C_20FieldType_20_3E_map" name="chemist::tensor::SparseShape_3C_20FieldType_20_3E_map">
<area href="classchemist_1_1tensor_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout." alt="chemist::tensor::Shape&lt; FieldType &gt;" shape="rect" coords="0,0,257,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9d469335f2347275bf470acf1ae20334"><td class="memItemLeft" align="right" valign="top"><a id="a9d469335f2347275bf470acf1ae20334"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#a9d469335f2347275bf470acf1ae20334">sparse_map_type</a> = <a class="el" href="classchemist_1_1sparse__map_1_1SparseMap_3_01ElementIndex_00_01ElementIndex_01_4.html">sparse_map::SparseMapEE</a></td></tr>
<tr class="memdesc:a9d469335f2347275bf470acf1ae20334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the sparse map taken as input. <br /></td></tr>
<tr class="separator:a9d469335f2347275bf470acf1ae20334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc4d70942b491e8a866cd6375c0681f"><td class="memItemLeft" align="right" valign="top"><a id="a9bc4d70942b491e8a866cd6375c0681f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#a9bc4d70942b491e8a866cd6375c0681f">const_sparse_map_reference</a> = const <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#a9d469335f2347275bf470acf1ae20334">sparse_map_type</a> &amp;</td></tr>
<tr class="memdesc:a9bc4d70942b491e8a866cd6375c0681f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to the sparse map the shape is using. <br /></td></tr>
<tr class="separator:a9bc4d70942b491e8a866cd6375c0681f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa645e4e5fd03d23f3912bf160bc15ffb"><td class="memItemLeft" align="right" valign="top"><a id="aa645e4e5fd03d23f3912bf160bc15ffb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#aa645e4e5fd03d23f3912bf160bc15ffb">idx2mode_type</a> = std::vector&lt; std::size_t &gt;</td></tr>
<tr class="memdesc:aa645e4e5fd03d23f3912bf160bc15ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the input mapping sparse map indices to tensor modes. <br /></td></tr>
<tr class="separator:aa645e4e5fd03d23f3912bf160bc15ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada08766d85dd2448cd9a5b1a4aa69f75"><td class="memItemLeft" align="right" valign="top"><a id="ada08766d85dd2448cd9a5b1a4aa69f75"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#ada08766d85dd2448cd9a5b1a4aa69f75">const_idx2mode_reference</a> = const <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#aa645e4e5fd03d23f3912bf160bc15ffb">idx2mode_type</a> &amp;</td></tr>
<tr class="memdesc:ada08766d85dd2448cd9a5b1a4aa69f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to the sparse map to tensor mode map. <br /></td></tr>
<tr class="separator:ada08766d85dd2448cd9a5b1a4aa69f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926d514cacc5abc8c348be5fbb878541"><td class="memItemLeft" align="right" valign="top"><a id="a926d514cacc5abc8c348be5fbb878541"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#a926d514cacc5abc8c348be5fbb878541">tensor_type</a> = typename backend_type::variant_type</td></tr>
<tr class="memdesc:a926d514cacc5abc8c348be5fbb878541"><td class="mdescLeft">&#160;</td><td class="mdescRight">How make_tensor returns the resulting tensor. <br /></td></tr>
<tr class="separator:a926d514cacc5abc8c348be5fbb878541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864fa74ae8c17bd653768334cce99f3a"><td class="memItemLeft" align="right" valign="top"><a id="a864fa74ae8c17bd653768334cce99f3a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#a864fa74ae8c17bd653768334cce99f3a">const_allocator_reference</a> = const <a class="el" href="classchemist_1_1tensor_1_1Shape.html#af3a834f168ba64e3086935b3307d474d">allocator_type</a> &amp;</td></tr>
<tr class="memdesc:a864fa74ae8c17bd653768334cce99f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only reference to an allocator. <br /></td></tr>
<tr class="separator:a864fa74ae8c17bd653768334cce99f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14643eb1cddff541aab607e6182696ef"><td class="memItemLeft" align="right" valign="top"><a id="a14643eb1cddff541aab607e6182696ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#a14643eb1cddff541aab607e6182696ef">extents_type</a> = std::vector&lt; <a class="el" href="classchemist_1_1tensor_1_1Shape.html#abc769fbe627a58af708064319d76fac8">size_type</a> &gt;</td></tr>
<tr class="memdesc:a14643eb1cddff541aab607e6182696ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to provide/return extents. <br /></td></tr>
<tr class="separator:a14643eb1cddff541aab607e6182696ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b8a3a362691a1a43b29d4b07a343f2"><td class="memItemLeft" align="right" valign="top"><a id="aa0b8a3a362691a1a43b29d4b07a343f2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#aa0b8a3a362691a1a43b29d4b07a343f2">pointer_type</a> = std::unique_ptr&lt; <a class="el" href="classchemist_1_1tensor_1_1Shape.html">my_type</a> &gt;</td></tr>
<tr class="memdesc:aa0b8a3a362691a1a43b29d4b07a343f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to this class. <br /></td></tr>
<tr class="separator:aa0b8a3a362691a1a43b29d4b07a343f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classchemist_1_1tensor_1_1Shape"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classchemist_1_1tensor_1_1Shape')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classchemist_1_1tensor_1_1Shape.html">chemist::tensor::Shape&lt; FieldType &gt;</a></td></tr>
<tr class="memitem:a0338a2499594e93669bbdc7bb8366666 inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a0338a2499594e93669bbdc7bb8366666"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#a0338a2499594e93669bbdc7bb8366666">pimpl_pointer</a> = std::unique_ptr&lt; <a class="el" href="classchemist_1_1tensor_1_1detail___1_1ShapePIMPL.html">pimpl_type</a> &gt;</td></tr>
<tr class="memdesc:a0338a2499594e93669bbdc7bb8366666 inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to a PIMPL instance. <br /></td></tr>
<tr class="separator:a0338a2499594e93669bbdc7bb8366666 inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f86d0af1aab9db778cea9ca52bc4ea inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a98f86d0af1aab9db778cea9ca52bc4ea"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#a98f86d0af1aab9db778cea9ca52bc4ea">field_type</a> = FieldType</td></tr>
<tr class="memdesc:a98f86d0af1aab9db778cea9ca52bc4ea inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the field the associated tensor is over. <br /></td></tr>
<tr class="separator:a98f86d0af1aab9db778cea9ca52bc4ea inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a834f168ba64e3086935b3307d474d inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="af3a834f168ba64e3086935b3307d474d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#af3a834f168ba64e3086935b3307d474d">allocator_type</a> = <a class="el" href="classchemist_1_1tensor_1_1Allocator.html">Allocator</a>&lt; <a class="el" href="classchemist_1_1tensor_1_1Shape.html#a98f86d0af1aab9db778cea9ca52bc4ea">field_type</a> &gt;</td></tr>
<tr class="memdesc:af3a834f168ba64e3086935b3307d474d inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type of an allocator associated with the same tensor. <br /></td></tr>
<tr class="separator:af3a834f168ba64e3086935b3307d474d inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864fa74ae8c17bd653768334cce99f3a inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a864fa74ae8c17bd653768334cce99f3a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#a864fa74ae8c17bd653768334cce99f3a">const_allocator_reference</a> = const <a class="el" href="classchemist_1_1tensor_1_1Shape.html#af3a834f168ba64e3086935b3307d474d">allocator_type</a> &amp;</td></tr>
<tr class="memdesc:a864fa74ae8c17bd653768334cce99f3a inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only reference to an allocator. <br /></td></tr>
<tr class="separator:a864fa74ae8c17bd653768334cce99f3a inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc769fbe627a58af708064319d76fac8 inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="abc769fbe627a58af708064319d76fac8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#abc769fbe627a58af708064319d76fac8">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:abc769fbe627a58af708064319d76fac8 inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for indexing and offsets. <br /></td></tr>
<tr class="separator:abc769fbe627a58af708064319d76fac8 inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14643eb1cddff541aab607e6182696ef inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a14643eb1cddff541aab607e6182696ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#a14643eb1cddff541aab607e6182696ef">extents_type</a> = std::vector&lt; <a class="el" href="classchemist_1_1tensor_1_1Shape.html#abc769fbe627a58af708064319d76fac8">size_type</a> &gt;</td></tr>
<tr class="memdesc:a14643eb1cddff541aab607e6182696ef inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to provide/return extents. <br /></td></tr>
<tr class="separator:a14643eb1cddff541aab607e6182696ef inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6b95576d59a1734281e435196b7897 inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="abd6b95576d59a1734281e435196b7897"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#abd6b95576d59a1734281e435196b7897">const_extents_reference</a> = const <a class="el" href="classchemist_1_1tensor_1_1Shape.html#a14643eb1cddff541aab607e6182696ef">extents_type</a> &amp;</td></tr>
<tr class="memdesc:abd6b95576d59a1734281e435196b7897 inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to the extents. <br /></td></tr>
<tr class="separator:abd6b95576d59a1734281e435196b7897 inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b8a3a362691a1a43b29d4b07a343f2 inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="aa0b8a3a362691a1a43b29d4b07a343f2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#aa0b8a3a362691a1a43b29d4b07a343f2">pointer_type</a> = std::unique_ptr&lt; <a class="el" href="classchemist_1_1tensor_1_1Shape.html">my_type</a> &gt;</td></tr>
<tr class="memdesc:aa0b8a3a362691a1a43b29d4b07a343f2 inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to this class. <br /></td></tr>
<tr class="separator:aa0b8a3a362691a1a43b29d4b07a343f2 inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926d514cacc5abc8c348be5fbb878541 inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a926d514cacc5abc8c348be5fbb878541"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#a926d514cacc5abc8c348be5fbb878541">tensor_type</a> = typename backend_type::variant_type</td></tr>
<tr class="memdesc:a926d514cacc5abc8c348be5fbb878541 inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">How make_tensor returns the resulting tensor. <br /></td></tr>
<tr class="separator:a926d514cacc5abc8c348be5fbb878541 inherit pub_types_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1a9e1ab01f9e6b0480ed42b6a65455a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#a1a9e1ab01f9e6b0480ed42b6a65455a0">SparseShape</a> (<a class="el" href="classchemist_1_1tensor_1_1Shape.html#a14643eb1cddff541aab607e6182696ef">extents_type</a> <a class="el" href="classchemist_1_1tensor_1_1Shape.html#a803bdc85c3c36d4f34c7e12ea3076090">extents</a>, <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#a9d469335f2347275bf470acf1ae20334">sparse_map_type</a> sm)</td></tr>
<tr class="memdesc:a1a9e1ab01f9e6b0480ed42b6a65455a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> from extents and a SparseMap.  <a href="classchemist_1_1tensor_1_1SparseShape.html#a1a9e1ab01f9e6b0480ed42b6a65455a0">More...</a><br /></td></tr>
<tr class="separator:a1a9e1ab01f9e6b0480ed42b6a65455a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a88cf771d911e2db630cc9afbb1093"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#ab6a88cf771d911e2db630cc9afbb1093">SparseShape</a> (<a class="el" href="classchemist_1_1tensor_1_1Shape.html#a14643eb1cddff541aab607e6182696ef">extents_type</a> <a class="el" href="classchemist_1_1tensor_1_1Shape.html#a803bdc85c3c36d4f34c7e12ea3076090">extents</a>, <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#a9d469335f2347275bf470acf1ae20334">sparse_map_type</a> sm, <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#aa645e4e5fd03d23f3912bf160bc15ffb">idx2mode_type</a> i2m)</td></tr>
<tr class="memdesc:ab6a88cf771d911e2db630cc9afbb1093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> from extents, a SparseMap, and a mapping from SparseMap indices to tensor modes.  <a href="classchemist_1_1tensor_1_1SparseShape.html#ab6a88cf771d911e2db630cc9afbb1093">More...</a><br /></td></tr>
<tr class="separator:ab6a88cf771d911e2db630cc9afbb1093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226a45f2081043ecd4d1c09104e7cf5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#a226a45f2081043ecd4d1c09104e7cf5d">operator==</a> (const <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html">SparseShape</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a226a45f2081043ecd4d1c09104e7cf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-polymorphic comparison of two <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances.  <a href="classchemist_1_1tensor_1_1SparseShape.html#a226a45f2081043ecd4d1c09104e7cf5d">More...</a><br /></td></tr>
<tr class="separator:a226a45f2081043ecd4d1c09104e7cf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975657563901c4fc3d6b423714fafb54"><td class="memTemplParams" colspan="2">template&lt;typename RHSField , typename  = disable_if_same_field_t&lt;RHSField&gt;&gt; </td></tr>
<tr class="memitem:a975657563901c4fc3d6b423714fafb54"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#a975657563901c4fc3d6b423714fafb54">operator==</a> (const <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html">SparseShape</a>&lt; RHSField &gt; &amp;) const noexcept</td></tr>
<tr class="memdesc:a975657563901c4fc3d6b423714fafb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements operator== for different fields.  <a href="classchemist_1_1tensor_1_1SparseShape.html#a975657563901c4fc3d6b423714fafb54">More...</a><br /></td></tr>
<tr class="separator:a975657563901c4fc3d6b423714fafb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e68f3e279a315691e514e9ff31bc34"><td class="memItemLeft" align="right" valign="top"><a id="a64e68f3e279a315691e514e9ff31bc34"></a>
<a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#a9bc4d70942b491e8a866cd6375c0681f">const_sparse_map_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sparse_map</b> () const</td></tr>
<tr class="separator:a64e68f3e279a315691e514e9ff31bc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06898dfcffb1d59743f77ccdac330df"><td class="memItemLeft" align="right" valign="top"><a id="af06898dfcffb1d59743f77ccdac330df"></a>
<a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#ada08766d85dd2448cd9a5b1a4aa69f75">const_idx2mode_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><b>idx2mode_map</b> () const</td></tr>
<tr class="separator:af06898dfcffb1d59743f77ccdac330df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classchemist_1_1tensor_1_1Shape"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classchemist_1_1tensor_1_1Shape')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classchemist_1_1tensor_1_1Shape.html">chemist::tensor::Shape&lt; FieldType &gt;</a></td></tr>
<tr class="memitem:a82a1d6d383f3e89332c8cf0a2c6e1767 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#a82a1d6d383f3e89332c8cf0a2c6e1767">Shape</a> () noexcept</td></tr>
<tr class="memdesc:a82a1d6d383f3e89332c8cf0a2c6e1767 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shape with no extents.  <a href="classchemist_1_1tensor_1_1Shape.html#a82a1d6d383f3e89332c8cf0a2c6e1767">More...</a><br /></td></tr>
<tr class="separator:a82a1d6d383f3e89332c8cf0a2c6e1767 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95d11aaa85738ec8920e087bebb18e1 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#ac95d11aaa85738ec8920e087bebb18e1">Shape</a> (<a class="el" href="classchemist_1_1tensor_1_1Shape.html#a14643eb1cddff541aab607e6182696ef">extents_type</a> <a class="el" href="classchemist_1_1tensor_1_1Shape.html#a803bdc85c3c36d4f34c7e12ea3076090">extents</a>)</td></tr>
<tr class="memdesc:ac95d11aaa85738ec8920e087bebb18e1 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shape with the provided extents.  <a href="classchemist_1_1tensor_1_1Shape.html#ac95d11aaa85738ec8920e087bebb18e1">More...</a><br /></td></tr>
<tr class="separator:ac95d11aaa85738ec8920e087bebb18e1 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81028290b89ac705bb9cfc70e35c092 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="ae81028290b89ac705bb9cfc70e35c092"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#ae81028290b89ac705bb9cfc70e35c092">~Shape</a> () noexcept</td></tr>
<tr class="memdesc:ae81028290b89ac705bb9cfc70e35c092 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted dtor. <br /></td></tr>
<tr class="separator:ae81028290b89ac705bb9cfc70e35c092 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea37ad0439ed735fcee01d949277e68 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#aa0b8a3a362691a1a43b29d4b07a343f2">pointer_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#a1ea37ad0439ed735fcee01d949277e68">clone</a> () const</td></tr>
<tr class="memdesc:a1ea37ad0439ed735fcee01d949277e68 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic deep-copy.  <a href="classchemist_1_1tensor_1_1Shape.html#a1ea37ad0439ed735fcee01d949277e68">More...</a><br /></td></tr>
<tr class="separator:a1ea37ad0439ed735fcee01d949277e68 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803bdc85c3c36d4f34c7e12ea3076090 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#abd6b95576d59a1734281e435196b7897">const_extents_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#a803bdc85c3c36d4f34c7e12ea3076090">extents</a> () const</td></tr>
<tr class="memdesc:a803bdc85c3c36d4f34c7e12ea3076090 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the extents of the tensor described by this <a class="el" href="classchemist_1_1tensor_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout.">Shape</a>.  <a href="classchemist_1_1tensor_1_1Shape.html#a803bdc85c3c36d4f34c7e12ea3076090">More...</a><br /></td></tr>
<tr class="separator:a803bdc85c3c36d4f34c7e12ea3076090 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6fc04a8a8cfa835b11c1b486fc2e3f inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#a926d514cacc5abc8c348be5fbb878541">tensor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#a7d6fc04a8a8cfa835b11c1b486fc2e3f">make_tensor</a> (<a class="el" href="classchemist_1_1tensor_1_1Shape.html#a864fa74ae8c17bd653768334cce99f3a">const_allocator_reference</a> p) const</td></tr>
<tr class="memdesc:a7d6fc04a8a8cfa835b11c1b486fc2e3f inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an allocator, this function will create a tensor consistent with the present <a class="el" href="classchemist_1_1tensor_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout.">Shape</a> instance.  <a href="classchemist_1_1tensor_1_1Shape.html#a7d6fc04a8a8cfa835b11c1b486fc2e3f">More...</a><br /></td></tr>
<tr class="separator:a7d6fc04a8a8cfa835b11c1b486fc2e3f inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d696e1e6bc4ec96a5343f1ae521232d inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#a8d696e1e6bc4ec96a5343f1ae521232d">operator==</a> (const <a class="el" href="classchemist_1_1tensor_1_1Shape.html">Shape</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a8d696e1e6bc4ec96a5343f1ae521232d inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-polymorphic equality comparison for shapes with the same field.  <a href="classchemist_1_1tensor_1_1Shape.html#a8d696e1e6bc4ec96a5343f1ae521232d">More...</a><br /></td></tr>
<tr class="separator:a8d696e1e6bc4ec96a5343f1ae521232d inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9630454e161ccb8e0142706a0f82bd04 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memTemplParams" colspan="2">template&lt;typename RHSType , typename  = enable_if_not_my_field_t&lt;RHSType&gt;&gt; </td></tr>
<tr class="memitem:a9630454e161ccb8e0142706a0f82bd04 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#a9630454e161ccb8e0142706a0f82bd04">operator==</a> (const <a class="el" href="classchemist_1_1tensor_1_1Shape.html">Shape</a>&lt; RHSType &gt; &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a9630454e161ccb8e0142706a0f82bd04 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-polymorphic equality comparison for Shapes with different fields.  <a href="classchemist_1_1tensor_1_1Shape.html#a9630454e161ccb8e0142706a0f82bd04">More...</a><br /></td></tr>
<tr class="separator:a9630454e161ccb8e0142706a0f82bd04 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b48f9a9c99c3b91b9166bf52c6a8398 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#a3b48f9a9c99c3b91b9166bf52c6a8398">is_equal</a> (const <a class="el" href="classchemist_1_1tensor_1_1Shape.html">Shape</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a3b48f9a9c99c3b91b9166bf52c6a8398 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic equality comparison.  <a href="classchemist_1_1tensor_1_1Shape.html#a3b48f9a9c99c3b91b9166bf52c6a8398">More...</a><br /></td></tr>
<tr class="separator:a3b48f9a9c99c3b91b9166bf52c6a8398 inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97001234420d5cff4407de29cface65e inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#a97001234420d5cff4407de29cface65e">hash</a> (pluginplay::Hasher &amp;h) const</td></tr>
<tr class="memdesc:a97001234420d5cff4407de29cface65e inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic hash function.  <a href="classchemist_1_1tensor_1_1Shape.html#a97001234420d5cff4407de29cface65e">More...</a><br /></td></tr>
<tr class="separator:a97001234420d5cff4407de29cface65e inherit pub_methods_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aec05155a9e238e095409193872e4e1cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#aec05155a9e238e095409193872e4e1cf">SparseShape</a> (const <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html">SparseShape</a> &amp;other)</td></tr>
<tr class="memdesc:aec05155a9e238e095409193872e4e1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a non-polymorphic copy of this instance.  <a href="classchemist_1_1tensor_1_1SparseShape.html#aec05155a9e238e095409193872e4e1cf">More...</a><br /></td></tr>
<tr class="separator:aec05155a9e238e095409193872e4e1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classchemist_1_1tensor_1_1Shape"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classchemist_1_1tensor_1_1Shape')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classchemist_1_1tensor_1_1Shape.html">chemist::tensor::Shape&lt; FieldType &gt;</a></td></tr>
<tr class="memitem:a16baa216a0c85ff8f0723930d90b9257 inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#a16baa216a0c85ff8f0723930d90b9257">Shape</a> (<a class="el" href="classchemist_1_1tensor_1_1Shape.html#a0338a2499594e93669bbdc7bb8366666">pimpl_pointer</a> pimpl) noexcept</td></tr>
<tr class="memdesc:a16baa216a0c85ff8f0723930d90b9257 inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the <a class="el" href="classchemist_1_1tensor_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout.">Shape</a> with the specified PIMPL.  <a href="classchemist_1_1tensor_1_1Shape.html#a16baa216a0c85ff8f0723930d90b9257">More...</a><br /></td></tr>
<tr class="separator:a16baa216a0c85ff8f0723930d90b9257 inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ab00d78c9405daf30d49005f3c00b8 inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classchemist_1_1tensor_1_1detail___1_1ShapePIMPL.html">pimpl_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#a15ab00d78c9405daf30d49005f3c00b8">pimpl_</a> () const</td></tr>
<tr class="memdesc:a15ab00d78c9405daf30d49005f3c00b8 inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the PIMPL in a read-only state.  <a href="classchemist_1_1tensor_1_1Shape.html#a15ab00d78c9405daf30d49005f3c00b8">More...</a><br /></td></tr>
<tr class="separator:a15ab00d78c9405daf30d49005f3c00b8 inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d5eea3eb0098f73b8fb81e67b6e22d inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#ab7d5eea3eb0098f73b8fb81e67b6e22d">assert_pimpl_</a> () const</td></tr>
<tr class="memdesc:ab7d5eea3eb0098f73b8fb81e67b6e22d inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises an exception if the <a class="el" href="classchemist_1_1tensor_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout.">Shape</a> instance does not contain a PIMPL.  <a href="classchemist_1_1tensor_1_1Shape.html#ab7d5eea3eb0098f73b8fb81e67b6e22d">More...</a><br /></td></tr>
<tr class="separator:ab7d5eea3eb0098f73b8fb81e67b6e22d inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0dc482e816b5a17f13e00cb14f97f2 inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#a9f0dc482e816b5a17f13e00cb14f97f2">has_pimpl_</a> () const noexcept</td></tr>
<tr class="memdesc:a9f0dc482e816b5a17f13e00cb14f97f2 inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the instance has a PIMPL or not.  <a href="classchemist_1_1tensor_1_1Shape.html#a9f0dc482e816b5a17f13e00cb14f97f2">More...</a><br /></td></tr>
<tr class="separator:a9f0dc482e816b5a17f13e00cb14f97f2 inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb6911f74fec45c42e615caa7967207 inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#accb6911f74fec45c42e615caa7967207">Shape</a> (const <a class="el" href="classchemist_1_1tensor_1_1Shape.html">Shape</a> &amp;other)=delete</td></tr>
<tr class="separator:accb6911f74fec45c42e615caa7967207 inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd19c0976db624eb0a732392512d7824 inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="abd19c0976db624eb0a732392512d7824"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Shape</b> (<a class="el" href="classchemist_1_1tensor_1_1Shape.html">Shape</a> &amp;&amp;other) noexcept=delete</td></tr>
<tr class="separator:abd19c0976db624eb0a732392512d7824 inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca80d0b6600eef69d2e25926e167a88 inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a1ca80d0b6600eef69d2e25926e167a88"></a>
<a class="el" href="classchemist_1_1tensor_1_1Shape.html">Shape</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classchemist_1_1tensor_1_1Shape.html">Shape</a> &amp;rhs)=delete</td></tr>
<tr class="separator:a1ca80d0b6600eef69d2e25926e167a88 inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee81afce591b70db79279bf09df31de inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a5ee81afce591b70db79279bf09df31de"></a>
<a class="el" href="classchemist_1_1tensor_1_1Shape.html">Shape</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classchemist_1_1tensor_1_1Shape.html">Shape</a> &amp;&amp;rhs) noexcept=delete</td></tr>
<tr class="separator:a5ee81afce591b70db79279bf09df31de inherit pro_methods_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ad74fa4db4f86c86b8826d964a0704751"><td class="memTemplParams" colspan="2">template&lt;typename LHSField , typename RHSField &gt; </td></tr>
<tr class="memitem:ad74fa4db4f86c86b8826d964a0704751"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#ad74fa4db4f86c86b8826d964a0704751">operator!=</a> (const <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html">SparseShape</a>&lt; LHSField &gt; &amp;lhs, const <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html">SparseShape</a>&lt; RHSField &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad74fa4db4f86c86b8826d964a0704751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances are different, non-polymorphically.  <a href="classchemist_1_1tensor_1_1SparseShape.html#ad74fa4db4f86c86b8826d964a0704751">More...</a><br /></td></tr>
<tr class="separator:ad74fa4db4f86c86b8826d964a0704751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classchemist_1_1tensor_1_1Shape"><td colspan="2" onclick="javascript:toggleInherit('related_classchemist_1_1tensor_1_1Shape')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classchemist_1_1tensor_1_1Shape.html">chemist::tensor::Shape&lt; FieldType &gt;</a></td></tr>
<tr class="memitem:aeaf2b480cf78a28a492aa683cd05a0dd inherit related_classchemist_1_1tensor_1_1Shape"><td class="memTemplParams" colspan="2">template&lt;typename LHSType , typename RHSType &gt; </td></tr>
<tr class="memitem:aeaf2b480cf78a28a492aa683cd05a0dd inherit related_classchemist_1_1tensor_1_1Shape"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#aeaf2b480cf78a28a492aa683cd05a0dd">operator!=</a> (const <a class="el" href="classchemist_1_1tensor_1_1Shape.html">Shape</a>&lt; LHSType &gt; &amp;lhs, const <a class="el" href="classchemist_1_1tensor_1_1Shape.html">Shape</a>&lt; RHSType &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aeaf2b480cf78a28a492aa683cd05a0dd inherit related_classchemist_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classchemist_1_1tensor_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout.">Shape</a> instances are different.  <a href="classchemist_1_1tensor_1_1Shape.html#aeaf2b480cf78a28a492aa683cd05a0dd">More...</a><br /></td></tr>
<tr class="separator:aeaf2b480cf78a28a492aa683cd05a0dd inherit related_classchemist_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename FieldType&gt;<br />
class chemist::tensor::SparseShape&lt; FieldType &gt;</h3>

<p>Describes a tensor's shape when there's sparsity. </p>
<p>This class uses a SparseMap and an allocator to properly determine which tiles are 0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FieldType</td><td>Type of the elements in the field associated with the tensor. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1a9e1ab01f9e6b0480ed42b6a65455a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9e1ab01f9e6b0480ed42b6a65455a0">&#9670;&nbsp;</a></span>SparseShape() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html">chemist::tensor::SparseShape</a>&lt; FieldType &gt;::<a class="el" href="classchemist_1_1tensor_1_1SparseShape.html">SparseShape</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#a14643eb1cddff541aab607e6182696ef">extents_type</a>&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#a9d469335f2347275bf470acf1ae20334">sparse_map_type</a>&#160;</td>
          <td class="paramname"><em>sm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> from extents and a SparseMap. </p>
<p>This ctor delegates to the primary constructor. It assumes that the mapping from an independent and dependent index to a tensor index is simply concatenation, <em>e.g.</em>, given independent index (1, 2) and dependent index (3, 4) this function assumes that the corresponding tensor index is (1, 2; 3, 4) (semi-colon separating outer and inner tensor indices). This constructor is primarily of use when the shape is describing a ToT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">extents</td><td>The length of each mode.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sm</td><td>The SparseMap specifying which dependent indices must be considered for a given independent index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the overall rank <code>sm</code> is inconsistent with the length of <code>extents</code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6a88cf771d911e2db630cc9afbb1093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a88cf771d911e2db630cc9afbb1093">&#9670;&nbsp;</a></span>SparseShape() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html">chemist::tensor::SparseShape</a>&lt; FieldType &gt;::<a class="el" href="classchemist_1_1tensor_1_1SparseShape.html">SparseShape</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchemist_1_1tensor_1_1Shape.html#a14643eb1cddff541aab607e6182696ef">extents_type</a>&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#a9d469335f2347275bf470acf1ae20334">sparse_map_type</a>&#160;</td>
          <td class="paramname"><em>sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#aa645e4e5fd03d23f3912bf160bc15ffb">idx2mode_type</a>&#160;</td>
          <td class="paramname"><em>i2m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> from extents, a SparseMap, and a mapping from SparseMap indices to tensor modes. </p>
<p>This is the primary constructor for creating a <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">extents</td><td>The length of each mode.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sm</td><td>The SparseMap containing a map from independent indices to non-zero dependent indices.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx2mode</td><td>Assuming <code>sm</code> contains independent indices of rank <img class="formulaInl" alt="$i$" src="form_12.png"/>, and dependent indices of rank <img class="formulaInl" alt="$d$" src="form_24.png"/>, <code>idx2mode</code> is an <img class="formulaInl" alt="$i + d$" src="form_25.png"/> element vector such that for <img class="formulaInl" alt="$j&lt;i$" src="form_26.png"/> <code>idx2mode[j]</code> is the mode of the shape that the <img class="formulaInl" alt="$j$" src="form_13.png"/>-th independent mode maps to. For <img class="formulaInl" alt="$i &lt;= j &lt; i + d$" src="form_27.png"/> <code>idx2mode[j]</code> is the mode of the shape that the <img class="formulaInl" alt="$j-i$" src="form_28.png"/>-th dependent mode maps to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the overall rank of <code>sm</code> is inconsistent with the length of <code>idx2mode</code>. Strong throw gurantee. </td></tr>
    <tr><td class="paramname">std::out_of_range</td><td>If any element of <code>idx2mode</code> is larger than the rank of the shape. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec05155a9e238e095409193872e4e1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec05155a9e238e095409193872e4e1cf">&#9670;&nbsp;</a></span>SparseShape() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1tensor_1_1SparseShape.html">chemist::tensor::SparseShape</a>&lt; FieldType &gt;::<a class="el" href="classchemist_1_1tensor_1_1SparseShape.html">SparseShape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html">SparseShape</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a non-polymorphic copy of this instance. </p>
<p>This copy operation will deep-copy all state in the <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> part of the object (including the <a class="el" href="classchemist_1_1tensor_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout.">Shape</a> base class). This function is primarily used to implement Clone.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The instance we are copying.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating memory. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a226a45f2081043ecd4d1c09104e7cf5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226a45f2081043ecd4d1c09104e7cf5d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html">chemist::tensor::SparseShape</a>&lt; FieldType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html">SparseShape</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-polymorphic comparison of two <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances. </p>
<p>Two <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances are equivalent if there base classes compare equal, they both have the same sparse map, and the sparse map indices are mapped to the tensor modes the same way. If a class derives from <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a>, any state in the derived class is not considered by this comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance we are comparing to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this instance compares equivalent to <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a975657563901c4fc3d6b423714fafb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975657563901c4fc3d6b423714fafb54">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<div class="memtemplate">
template&lt;typename RHSField , typename  = disable_if_same_field_t&lt;RHSField&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html">chemist::tensor::SparseShape</a>&lt; FieldType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html">SparseShape</a>&lt; RHSField &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements operator== for different fields. </p>
<p>If two <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances have different fields they are not equal. This function is chosen when the two <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances have different fields and will return false.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RHSField</td><td>The type of field <code>rhs</code> is defined over. Assumed to be either <a class="el" href="structchemist_1_1tensor_1_1field_1_1Scalar.html" title="Represents a field containing real or complex numbers.">field::Scalar</a> or <a class="el" href="structchemist_1_1tensor_1_1field_1_1Tensor.html" title="Represents a field containing tensors.">field::Tensor</a>. </td></tr>
    <tr><td class="paramname">&lt;anonymous&gt;</td><td>Used to enable this function, via SFINAE, when <code>RHSField</code> is different from FieldType.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance we are comparing to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False. This function is only used when the fields are different, in which case the shapes are also different.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ad74fa4db4f86c86b8826d964a0704751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74fa4db4f86c86b8826d964a0704751">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHSField , typename RHSField &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html">SparseShape</a>&lt; LHSField &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html">SparseShape</a>&lt; RHSField &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances are different, non-polymorphically. </p>
<p>This function simply negates <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#a226a45f2081043ecd4d1c09104e7cf5d" title="Non-polymorphic comparison of two SparseShape instances.">SparseShape::operator==</a>. See documentation for <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html#a226a45f2081043ecd4d1c09104e7cf5d" title="Non-polymorphic comparison of two SparseShape instances.">SparseShape::operator==</a> for what constitutes equivalency for <a class="el" href="classchemist_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHSField</td><td>The type of the field associated with <code>lhs</code>. Assumed to be either <a class="el" href="structchemist_1_1tensor_1_1field_1_1Scalar.html" title="Represents a field containing real or complex numbers.">field::Scalar</a> or <a class="el" href="structchemist_1_1tensor_1_1field_1_1Tensor.html" title="Represents a field containing tensors.">field::Tensor</a>. </td></tr>
    <tr><td class="paramname">RHSField</td><td>The type of the field associated with <code>rhs</code>. Assumed to be either <a class="el" href="structchemist_1_1tensor_1_1field_1_1Scalar.html" title="Represents a field containing real or complex numbers.">field::Scalar</a> or <a class="el" href="structchemist_1_1tensor_1_1field_1_1Tensor.html" title="Represents a field containing tensors.">field::Tensor</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The shape instance on the left side of the comparison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The shape instance on the right side of the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if <code>lhs</code> and <code>rhs</code> compare equal and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/chemist/tensor/shapes/<a class="el" href="sparse__shape_8hpp_source.html">sparse_shape.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
