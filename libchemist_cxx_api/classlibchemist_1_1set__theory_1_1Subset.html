<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libchemist: libchemist::set_theory::Subset&lt; SetType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libchemist
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibchemist.html">libchemist</a></li><li class="navelem"><b>set_theory</b></li><li class="navelem"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">Subset</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classlibchemist_1_1set__theory_1_1Subset-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libchemist::set_theory::Subset&lt; SetType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Models a subset of a set.  
 <a href="classlibchemist_1_1set__theory_1_1Subset.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="subset_8hpp_source.html">subset.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afb40bcc120a5ffd168c587a5b026cf09"><td class="memItemLeft" align="right" valign="top"><a id="afb40bcc120a5ffd168c587a5b026cf09"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#afb40bcc120a5ffd168c587a5b026cf09">value_type</a> = typename <a class="el" href="structlibchemist_1_1set__theory_1_1SetTraits.html#a9e81edeea8413598195b561b5143558e">traits_type::value_type</a></td></tr>
<tr class="memdesc:afb40bcc120a5ffd168c587a5b026cf09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the elements in SetType. <br /></td></tr>
<tr class="separator:afb40bcc120a5ffd168c587a5b026cf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ddf03b512f76e5d5ceb416aed7ad9b"><td class="memItemLeft" align="right" valign="top"><a id="a67ddf03b512f76e5d5ceb416aed7ad9b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a67ddf03b512f76e5d5ceb416aed7ad9b">const_reference</a> = typename <a class="el" href="structlibchemist_1_1set__theory_1_1SetTraits.html#a353e24112e6a1faf9cb81e27c07135ff">traits_type::const_reference</a></td></tr>
<tr class="memdesc:a67ddf03b512f76e5d5ceb416aed7ad9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to an element of a SetType object. <br /></td></tr>
<tr class="separator:a67ddf03b512f76e5d5ceb416aed7ad9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7442fe2c50e4d4fbeed21504b38e8f9c"><td class="memItemLeft" align="right" valign="top"><a id="a7442fe2c50e4d4fbeed21504b38e8f9c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a7442fe2c50e4d4fbeed21504b38e8f9c">size_type</a> = typename <a class="el" href="structlibchemist_1_1set__theory_1_1SetTraits.html#a361a16d5555bc6e24c7986304f60b15f">traits_type::size_type</a></td></tr>
<tr class="memdesc:a7442fe2c50e4d4fbeed21504b38e8f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that SetType uses for indexing and offsets. <br /></td></tr>
<tr class="separator:a7442fe2c50e4d4fbeed21504b38e8f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03aea13521257c0db7c1420e5f4e3fb8"><td class="memItemLeft" align="right" valign="top"><a id="a03aea13521257c0db7c1420e5f4e3fb8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a03aea13521257c0db7c1420e5f4e3fb8">object_type</a> = SetType</td></tr>
<tr class="memdesc:a03aea13521257c0db7c1420e5f4e3fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the object this is a view of. <br /></td></tr>
<tr class="separator:a03aea13521257c0db7c1420e5f4e3fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace730d642219c65ab9210ab7528ceab0"><td class="memItemLeft" align="right" valign="top"><a id="ace730d642219c65ab9210ab7528ceab0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#ace730d642219c65ab9210ab7528ceab0">object_ptr</a> = std::shared_ptr&lt; const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a03aea13521257c0db7c1420e5f4e3fb8">object_type</a> &gt;</td></tr>
<tr class="memdesc:ace730d642219c65ab9210ab7528ceab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to the object this is a view of. <br /></td></tr>
<tr class="separator:ace730d642219c65ab9210ab7528ceab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e1b4c2d020066d9e0601793a472e7f"><td class="memItemLeft" align="right" valign="top"><a id="aa7e1b4c2d020066d9e0601793a472e7f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#aa7e1b4c2d020066d9e0601793a472e7f">const_obj_ref</a> = const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a03aea13521257c0db7c1420e5f4e3fb8">object_type</a> &amp;</td></tr>
<tr class="memdesc:aa7e1b4c2d020066d9e0601793a472e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to the object this is a view of. <br /></td></tr>
<tr class="separator:aa7e1b4c2d020066d9e0601793a472e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0e55480825d7527cb306384dc46f5666"><td class="memTemplParams" colspan="2">template&lt;typename ElemType  = size_type&gt; </td></tr>
<tr class="memitem:a0e55480825d7527cb306384dc46f5666"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a0e55480825d7527cb306384dc46f5666">Subset</a> (<a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#ace730d642219c65ab9210ab7528ceab0">object_ptr</a> parent, std::initializer_list&lt; ElemType &gt; il={})</td></tr>
<tr class="memdesc:a0e55480825d7527cb306384dc46f5666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new subset of <code>parent</code> with the elements specified in the provided initializer list.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#a0e55480825d7527cb306384dc46f5666">More...</a><br /></td></tr>
<tr class="separator:a0e55480825d7527cb306384dc46f5666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af914df940d80e3c255d8c4ae7bb427ee"><td class="memTemplParams" colspan="2">template&lt;typename BeginItr , typename EndItr &gt; </td></tr>
<tr class="memitem:af914df940d80e3c255d8c4ae7bb427ee"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#af914df940d80e3c255d8c4ae7bb427ee">Subset</a> (<a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#ace730d642219c65ab9210ab7528ceab0">object_ptr</a> parent, BeginItr &amp;&amp;b, EndItr &amp;&amp;e)</td></tr>
<tr class="memdesc:af914df940d80e3c255d8c4ae7bb427ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new subset initialized by the provided iterators.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#af914df940d80e3c255d8c4ae7bb427ee">More...</a><br /></td></tr>
<tr class="separator:af914df940d80e3c255d8c4ae7bb427ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa444418a9143ec2f73bcb4df7b161563"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a7442fe2c50e4d4fbeed21504b38e8f9c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#aa444418a9143ec2f73bcb4df7b161563">size</a> () const noexcept</td></tr>
<tr class="memdesc:aa444418a9143ec2f73bcb4df7b161563"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of elements in this <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html" title="Models a subset of a set.">Subset</a>.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#aa444418a9143ec2f73bcb4df7b161563">More...</a><br /></td></tr>
<tr class="separator:aa444418a9143ec2f73bcb4df7b161563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4385894e48e74549cf6c22c747a7b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#add4385894e48e74549cf6c22c747a7b1">empty</a> () const noexcept</td></tr>
<tr class="memdesc:add4385894e48e74549cf6c22c747a7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this subset is empty or not.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#add4385894e48e74549cf6c22c747a7b1">More...</a><br /></td></tr>
<tr class="separator:add4385894e48e74549cf6c22c747a7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a67dc2e8dda5bbf45794b142d56a3c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a57a67dc2e8dda5bbf45794b142d56a3c">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a57a67dc2e8dda5bbf45794b142d56a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only iterator pointing to the index of the first element in the subset.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#a57a67dc2e8dda5bbf45794b142d56a3c">More...</a><br /></td></tr>
<tr class="separator:a57a67dc2e8dda5bbf45794b142d56a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9771b23a7547107be33b63d53261526"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#ad9771b23a7547107be33b63d53261526">end</a> () const noexcept</td></tr>
<tr class="memdesc:ad9771b23a7547107be33b63d53261526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only iterator pointing to just past the index of the last element in the subset.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#ad9771b23a7547107be33b63d53261526">More...</a><br /></td></tr>
<tr class="separator:ad9771b23a7547107be33b63d53261526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9916f624fd661072e430082c9029a5eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a67ddf03b512f76e5d5ceb416aed7ad9b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a9916f624fd661072e430082c9029a5eb">at</a> (<a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a7442fe2c50e4d4fbeed21504b38e8f9c">size_type</a> i) const</td></tr>
<tr class="memdesc:a9916f624fd661072e430082c9029a5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an element of this subset by offset.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#a9916f624fd661072e430082c9029a5eb">More...</a><br /></td></tr>
<tr class="separator:a9916f624fd661072e430082c9029a5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4984297611ceee6ba101cb77a17903"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a67ddf03b512f76e5d5ceb416aed7ad9b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a0c4984297611ceee6ba101cb77a17903">operator[]</a> (<a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a7442fe2c50e4d4fbeed21504b38e8f9c">size_type</a> i) const</td></tr>
<tr class="memdesc:a0c4984297611ceee6ba101cb77a17903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an element of this subset by offset.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#a0c4984297611ceee6ba101cb77a17903">More...</a><br /></td></tr>
<tr class="separator:a0c4984297611ceee6ba101cb77a17903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a8349fe73c0bb8f788c3c5958d9433"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a14a8349fe73c0bb8f788c3c5958d9433">count</a> (<a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a67ddf03b512f76e5d5ceb416aed7ad9b">const_reference</a> elem) const</td></tr>
<tr class="memdesc:a14a8349fe73c0bb8f788c3c5958d9433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times <code>elem</code> appears in this subset.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#a14a8349fe73c0bb8f788c3c5958d9433">More...</a><br /></td></tr>
<tr class="separator:a14a8349fe73c0bb8f788c3c5958d9433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbbd0db79e84eb5820a7cfe61031c02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#aa7e1b4c2d020066d9e0601793a472e7f">const_obj_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a6dbbd0db79e84eb5820a7cfe61031c02">object</a> () const</td></tr>
<tr class="memdesc:a6dbbd0db79e84eb5820a7cfe61031c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only reference to the parent set.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#a6dbbd0db79e84eb5820a7cfe61031c02">More...</a><br /></td></tr>
<tr class="separator:a6dbbd0db79e84eb5820a7cfe61031c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fc4a85984b53f9ac4303d3c0e04642"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a65fc4a85984b53f9ac4303d3c0e04642">insert</a> (<a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a7442fe2c50e4d4fbeed21504b38e8f9c">size_type</a> i)</td></tr>
<tr class="memdesc:a65fc4a85984b53f9ac4303d3c0e04642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element by offset in the parent set.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#a65fc4a85984b53f9ac4303d3c0e04642">More...</a><br /></td></tr>
<tr class="separator:a65fc4a85984b53f9ac4303d3c0e04642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a37eaafc7e4fefbe49c5a1086e0c3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a40a37eaafc7e4fefbe49c5a1086e0c3c">insert</a> (<a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a67ddf03b512f76e5d5ceb416aed7ad9b">const_reference</a> elem)</td></tr>
<tr class="memdesc:a40a37eaafc7e4fefbe49c5a1086e0c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element by value.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#a40a37eaafc7e4fefbe49c5a1086e0c3c">More...</a><br /></td></tr>
<tr class="separator:a40a37eaafc7e4fefbe49c5a1086e0c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7f26830666968c3b5fafe8c8b9d778"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a6b7f26830666968c3b5fafe8c8b9d778">operator+=</a> (const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> &amp;rhs)</td></tr>
<tr class="memdesc:a6b7f26830666968c3b5fafe8c8b9d778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this instance the union of itself and <code>rhs</code>.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#a6b7f26830666968c3b5fafe8c8b9d778">More...</a><br /></td></tr>
<tr class="separator:a6b7f26830666968c3b5fafe8c8b9d778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49425254cbcbb7fad6e91cf25dbf540"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#aa49425254cbcbb7fad6e91cf25dbf540">operator+</a> (const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> &amp;rhs) const</td></tr>
<tr class="memdesc:aa49425254cbcbb7fad6e91cf25dbf540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of this instance with <code>rhs</code>.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#aa49425254cbcbb7fad6e91cf25dbf540">More...</a><br /></td></tr>
<tr class="separator:aa49425254cbcbb7fad6e91cf25dbf540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f74d1f8792ef8e3f259b38f08bd69b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#ab4f74d1f8792ef8e3f259b38f08bd69b">operator-=</a> (const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> &amp;rhs)</td></tr>
<tr class="memdesc:ab4f74d1f8792ef8e3f259b38f08bd69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <code>rhs</code> from the current set.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#ab4f74d1f8792ef8e3f259b38f08bd69b">More...</a><br /></td></tr>
<tr class="separator:ab4f74d1f8792ef8e3f259b38f08bd69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b772f1774685db44b1ef063991f59cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a8b772f1774685db44b1ef063991f59cd">operator-</a> (const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a8b772f1774685db44b1ef063991f59cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set difference of this with <code>rhs</code>.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#a8b772f1774685db44b1ef063991f59cd">More...</a><br /></td></tr>
<tr class="separator:a8b772f1774685db44b1ef063991f59cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8267759ca50b480285b6f89b2a202e03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a8267759ca50b480285b6f89b2a202e03">operator^=</a> (const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> &amp;rhs)</td></tr>
<tr class="memdesc:a8267759ca50b480285b6f89b2a202e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the intersection of itself with <code>rhs</code>.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#a8267759ca50b480285b6f89b2a202e03">More...</a><br /></td></tr>
<tr class="separator:a8267759ca50b480285b6f89b2a202e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79995ff6b19c717db1aa0ea34cf97e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#ab79995ff6b19c717db1aa0ea34cf97e3">operator^</a> (const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ab79995ff6b19c717db1aa0ea34cf97e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection of this with <code>rhs</code>.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#ab79995ff6b19c717db1aa0ea34cf97e3">More...</a><br /></td></tr>
<tr class="separator:ab79995ff6b19c717db1aa0ea34cf97e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299321b6ea4f90fafa4710436ec448e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a299321b6ea4f90fafa4710436ec448e7">operator&lt;</a> (const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a299321b6ea4f90fafa4710436ec448e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html" title="Models a subset of a set.">Subset</a> comes before <code>rhs</code> lexicographically.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#a299321b6ea4f90fafa4710436ec448e7">More...</a><br /></td></tr>
<tr class="separator:a299321b6ea4f90fafa4710436ec448e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7492d7e1ca129e0c016af81725424f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#adb7492d7e1ca129e0c016af81725424f">hash</a> (pluginplay::Hasher &amp;h) const</td></tr>
<tr class="memdesc:adb7492d7e1ca129e0c016af81725424f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes the current subset.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#adb7492d7e1ca129e0c016af81725424f">More...</a><br /></td></tr>
<tr class="separator:adb7492d7e1ca129e0c016af81725424f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ab3e249ecd942c78f8cf49ffd6023b0e4"><td class="memTemplParams" colspan="2">template&lt;typename LHSSetType , typename RHSSetType &gt; </td></tr>
<tr class="memitem:ab3e249ecd942c78f8cf49ffd6023b0e4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#ab3e249ecd942c78f8cf49ffd6023b0e4">operator==</a> (const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">Subset</a>&lt; LHSSetType &gt; &amp;lhs, const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">Subset</a>&lt; RHSSetType &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab3e249ecd942c78f8cf49ffd6023b0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html" title="Models a subset of a set.">Subset</a> instances for equality.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#ab3e249ecd942c78f8cf49ffd6023b0e4">More...</a><br /></td></tr>
<tr class="separator:ab3e249ecd942c78f8cf49ffd6023b0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee925edcede08ec92a7fccab88c89251"><td class="memTemplParams" colspan="2">template&lt;typename LHSSetType , typename RHSSetType &gt; </td></tr>
<tr class="memitem:aee925edcede08ec92a7fccab88c89251"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#aee925edcede08ec92a7fccab88c89251">operator!=</a> (const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">Subset</a>&lt; LHSSetType &gt; &amp;lhs, const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">Subset</a>&lt; RHSSetType &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aee925edcede08ec92a7fccab88c89251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html" title="Models a subset of a set.">Subset</a> instances are different.  <a href="classlibchemist_1_1set__theory_1_1Subset.html#aee925edcede08ec92a7fccab88c89251">More...</a><br /></td></tr>
<tr class="separator:aee925edcede08ec92a7fccab88c89251"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename SetType&gt;<br />
class libchemist::set_theory::Subset&lt; SetType &gt;</h3>

<p>Models a subset of a set. </p>
<p>Given a set <img class="formulaInl" alt="$\mathbb{S}$" src="form_47.png"/>, <img class="formulaInl" alt="$\mathbb{T}$" src="form_48.png"/> is a subset of <img class="formulaInl" alt="$\mathbb{S}$" src="form_47.png"/> if <img class="formulaInl" alt="$\mathbb{T}$" src="form_48.png"/> is a set and if every member of <img class="formulaInl" alt="$\mathbb{T}$" src="form_48.png"/> is also a member of <img class="formulaInl" alt="$\mathbb{S}$" src="form_47.png"/>. <img class="formulaInl" alt="$\mathbb{T}$" src="form_48.png"/> is a proper subset if at least one member of <img class="formulaInl" alt="$\mathbb{S}$" src="form_47.png"/> does not appear in <img class="formulaInl" alt="$\mathbb{T}$" src="form_48.png"/>.</p>
<p>Programatically, this class serves as a proxy for an object of type <code>SetType</code> whose members are restricted to being a subset of another <code>SetType</code> instance. This proxy is a view/mask of the <code>SetType</code> instance with limited <code>SetType</code> functionality (mainly the ability to determine if members are in the proxy and the ability to iterate over the members of the proxy).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SetType</td><td>Type of the parent set this <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html" title="Models a subset of a set.">Subset</a> instance is a subset of. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0e55480825d7527cb306384dc46f5666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e55480825d7527cb306384dc46f5666">&#9670;&nbsp;</a></span>Subset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
<div class="memtemplate">
template&lt;typename ElemType  = size_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::<a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">Subset</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#ace730d642219c65ab9210ab7528ceab0">object_ptr</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; ElemType &gt;&#160;</td>
          <td class="paramname"><em>il</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new subset of <code>parent</code> with the elements specified in the provided initializer list. </p>
<p>This ctor creates a new subset of <code>parent</code>. The subset will be empty if no initializer list is provided. Additional elements can be added by calling <code>insert</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ElemType</td><td>The type used to specify elements of <code>parent</code>. <code>ElemType</code> is expected to be implicitly convertible to either size_type or to value_type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>The set that this is a subset of. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>The elements to populate the subset with. Defaults to an empty list, which in turn creates an empty subset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>parent</code> is a null pointer. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::out_of_range</td><td>if any of the elements in <code>il</code> are not in <code>parent</code>. Weak throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af914df940d80e3c255d8c4ae7bb427ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af914df940d80e3c255d8c4ae7bb427ee">&#9670;&nbsp;</a></span>Subset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
<div class="memtemplate">
template&lt;typename BeginItr , typename EndItr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::<a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">Subset</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#ace730d642219c65ab9210ab7528ceab0">object_ptr</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginItr &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndItr &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new subset initialized by the provided iterators. </p>
<p>This ctor is used to initialize the subset given a range of elements specified by two iterators.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BeginItr</td><td>Type of the iterator pointing to the first element to be added. Can dereference to either an offset or the actual element. </td></tr>
    <tr><td class="paramname">EndItr</td><td>Type of the iterator pointing to just past the last element to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>The superset this set is a subset of. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The iterator pointing to the first element to include in this subset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>The iterator pointing to just past the last element to include in this subset. It is undefined behavior if <code>e</code> is not reachable by incrementing <code>b</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>parent</code> is a null pointer. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::out_of_range</td><td>if any of the elements in the provided range are not in <code>parent</code>. Weak throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9916f624fd661072e430082c9029a5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9916f624fd661072e430082c9029a5eb">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a67ddf03b512f76e5d5ceb416aed7ad9b">const_reference</a> <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a7442fe2c50e4d4fbeed21504b38e8f9c">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an element of this subset by offset. </p>
<p>This function can be used to retrieve an element of the subset by offset. It behave similar to <code>operator[]</code> with the addition of a bounds check on <code>i</code>. If you know that <code>i</code> is in bounds it is recommended that you call <code>operator[]</code> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The offset of the requested element. <code>i</code> must be in the range [0, <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#aa444418a9143ec2f73bcb4df7b161563" title="The number of elements in this Subset.">size()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only reference to the requested object.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>i</code> is not in the range [0, <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#aa444418a9143ec2f73bcb4df7b161563" title="The number of elements in this Subset.">size()</a>). Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57a67dc2e8dda5bbf45794b142d56a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a67dc2e8dda5bbf45794b142d56a3c">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only iterator pointing to the index of the first element in the subset. </p>
<p>For computational efficiency the iterators over the subset class run over the indices of the elements in the subset and not the elements themselves.</p>
<dl class="section return"><dt>Returns</dt><dd>An interator pointing to the index of the first element in this subset.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14a8349fe73c0bb8f788c3c5958d9433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a8349fe73c0bb8f788c3c5958d9433">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a67ddf03b512f76e5d5ceb416aed7ad9b">const_reference</a>&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of times <code>elem</code> appears in this subset. </p>
<p>This function allows you to determine how many times the object <code>elem</code> appears in this <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html" title="Models a subset of a set.">Subset</a>. Since the <code>elem</code> may appear at most once in this set, the result is either 0 or 1, i.e., true if <code>elem</code> is in the set and false if it is not. No check is made to ensure that <code>elem</code> is actually in the parent set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element we are looking for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>elem</code> is in the set and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add4385894e48e74549cf6c22c747a7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4385894e48e74549cf6c22c747a7b1">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this subset is empty or not. </p>
<p>This function is a convenience function for determining if the size of this set is zero.</p>
<dl class="section return"><dt>Returns</dt><dd>True if this set is empty (zero elements) and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw gurantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9771b23a7547107be33b63d53261526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9771b23a7547107be33b63d53261526">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only iterator pointing to just past the index of the last element in the subset. </p>
<p>For computational efficiency the iterators over the subset class run over the indices of the elements in the subset and not the elements themselves.</p>
<dl class="section return"><dt>Returns</dt><dd>An interator pointing to just past the index of the last element in this subset.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb7492d7e1ca129e0c016af81725424f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7492d7e1ca129e0c016af81725424f">&#9670;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::hash </td>
          <td>(</td>
          <td class="paramtype">pluginplay::Hasher &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes the current subset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">h</td><td>The hasher being used to hash this <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html" title="Models a subset of a set.">Subset</a>. After the call, the internal hash of <code>h</code> will be updated to include the hash of this <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html" title="Models a subset of a set.">Subset</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40a37eaafc7e4fefbe49c5a1086e0c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a37eaafc7e4fefbe49c5a1086e0c3c">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a67ddf03b512f76e5d5ceb416aed7ad9b">const_reference</a>&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts an element by value. </p>
<p>This function allows you to insert the specified element into the subset. The element must appear in the parent set. Repeated insertions of the same element do not change the state of the <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html" title="Models a subset of a set.">Subset</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to add to this subset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>elem</code> is not found in <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a6dbbd0db79e84eb5820a7cfe61031c02" title="Returns a read-only reference to the parent set.">object()</a>. Strong throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Be very careful using insert when the parent set is filled with objects of type <code>size_type</code>. In this case the only distinction between insertion by offset and insertion by value is whether or not the argument is a reference or value. This is particularly tricky given implicit conversion rules. That all said using the FamilyOfSets/Subset classes for a container filled with objects of <code>size_type</code> is more costly than actually having copies on account of the additional indirection. Hence this is considered a sufficiently rare edge-case that we are okay with the weird semantics for it. </dd></dl>

</div>
</div>
<a id="a65fc4a85984b53f9ac4303d3c0e04642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65fc4a85984b53f9ac4303d3c0e04642">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a7442fe2c50e4d4fbeed21504b38e8f9c">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts an element by offset in the parent set. </p>
<p>This function provides a mechanism for adding elements of the parent set to this subset by using the offset of the element. The offset is the offset in the parent set. Repeated insertions of an element do not change the state of the <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html" title="Models a subset of a set.">Subset</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The offset of the element we are inserting. Must be in the range [0, traits_type::size(object())).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>i</code> is not in the range [0,traits_type::size(object())). Strong throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Be very careful using insert when the parent set is filled with objects of type <code>size_type</code>. In this case the only distinction between insertion by offset and insertion by value is whether or not the argument is a reference or value. This is particularly tricky given implicit conversion rules. That all said using the FamilyOfSets/Subset classes for a container filled with objects of <code>size_type</code> is more costly than actually having copies on account of the additional indirection. Hence this is considered a sufficiently rare edge-case that we are okay with the weird semantics for it. </dd></dl>

</div>
</div>
<a id="a6dbbd0db79e84eb5820a7cfe61031c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dbbd0db79e84eb5820a7cfe61031c02">&#9670;&nbsp;</a></span>object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#aa7e1b4c2d020066d9e0601793a472e7f">const_obj_ref</a> <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only reference to the parent set. </p>
<p>This accessor can be used to retrieve the parent set that this instance is a subset of. N.B. this is the object living in the <a class="el" href="classlibchemist_1_1set__theory_1_1FamilyOfSets.html" title="Holds a series of Subset objects.">FamilyOfSets</a> not the <a class="el" href="classlibchemist_1_1set__theory_1_1FamilyOfSets.html" title="Holds a series of Subset objects.">FamilyOfSets</a> instance.</p>
<dl class="section return"><dt>Returns</dt><dd>A read-only reference to the parent set.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa49425254cbcbb7fad6e91cf25dbf540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49425254cbcbb7fad6e91cf25dbf540">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the union of this instance with <code>rhs</code>. </p>
<p>The union of two sets <img class="formulaInl" alt="$A$" src="form_4.png"/> and <img class="formulaInl" alt="$B$" src="form_6.png"/> is a set <img class="formulaInl" alt="$C$" src="form_8.png"/> such that every element in <img class="formulaInl" alt="$A$" src="form_4.png"/> and <img class="formulaInl" alt="$B$" src="form_6.png"/> is also in <img class="formulaInl" alt="$C$" src="form_8.png"/>. This function will compute the union of the current subset with <code>rhs</code> and return it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance we are taking the union with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The union of this instance with <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>rhs</code> has a different parent set than the current instance. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating memory. Weak throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b7f26830666968c3b5fafe8c8b9d778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7f26830666968c3b5fafe8c8b9d778">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a>&amp; <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes this instance the union of itself and <code>rhs</code>. </p>
<p>The union of two sets <img class="formulaInl" alt="$A$" src="form_4.png"/> and <img class="formulaInl" alt="$B$" src="form_6.png"/> is a set <img class="formulaInl" alt="$C$" src="form_8.png"/> such that every element in <img class="formulaInl" alt="$A$" src="form_4.png"/> and <img class="formulaInl" alt="$B$" src="form_6.png"/> is also in <img class="formulaInl" alt="$C$" src="form_8.png"/>. This function will overwrite the current subset's state with the union of itself and <code>rhs</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html" title="Models a subset of a set.">Subset</a> we are taking a union with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance after taking the union with <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>rhs</code> has a different parent set. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if memory allocation fails. Weak throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b772f1774685db44b1ef063991f59cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b772f1774685db44b1ef063991f59cd">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set difference of this with <code>rhs</code>. </p>
<p>The set difference of two sets, <img class="formulaInl" alt="$A$" src="form_4.png"/> and <img class="formulaInl" alt="$B$" src="form_6.png"/>, is a set <img class="formulaInl" alt="$C$" src="form_8.png"/> which contains all of the elements in <img class="formulaInl" alt="$A$" src="form_4.png"/> that are not in <img class="formulaInl" alt="$B$" src="form_6.png"/>. This function will return the set difference of the current instance with <code>rhs</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The current subset after setting it to the set difference with <code>rhs</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The set we are taking the set difference with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>rhs</code> has a different parent set. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if a memory allocation problem occurs. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4f74d1f8792ef8e3f259b38f08bd69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f74d1f8792ef8e3f259b38f08bd69b">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a>&amp; <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes <code>rhs</code> from the current set. </p>
<p>The set difference of two sets, <img class="formulaInl" alt="$A$" src="form_4.png"/> and <img class="formulaInl" alt="$B$" src="form_6.png"/>, is a set <img class="formulaInl" alt="$C$" src="form_8.png"/> which contains all of the elements in <img class="formulaInl" alt="$A$" src="form_4.png"/> that are not in <img class="formulaInl" alt="$B$" src="form_6.png"/>. This function will set the current instance to the set difference of itself with <code>rhs</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The current subset after setting it to the set difference with <code>rhs</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The set we are taking the set difference with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>rhs</code> has a different parent set. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating memory. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a299321b6ea4f90fafa4710436ec448e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299321b6ea4f90fafa4710436ec448e7">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html" title="Models a subset of a set.">Subset</a> comes before <code>rhs</code> lexicographically. </p>
<p>This function will compare the current subset to <code>rhs</code> and determine if it comes before it. The comparison is done on the element's offsets and not the elements themselves. That is to say the set <code>{0, 1}</code> comes before the set <code>{0, 2}</code> even if the <code><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a6dbbd0db79e84eb5820a7cfe61031c02" title="Returns a read-only reference to the parent set.">object()</a>[1]</code> comes after <code><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a6dbbd0db79e84eb5820a7cfe61031c02" title="Returns a read-only reference to the parent set.">object()</a>[2]</code> when sorting the objects.</p>
<p>In order to be no-throw this function assumes that the <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html" title="Models a subset of a set.">Subset</a> instances are subsets of the same superset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance we are comparing to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this instance is lexicographically ordered before <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c4984297611ceee6ba101cb77a17903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4984297611ceee6ba101cb77a17903">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a67ddf03b512f76e5d5ceb416aed7ad9b">const_reference</a> <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a7442fe2c50e4d4fbeed21504b38e8f9c">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an element of this subset by offset. </p>
<p>This function works similar to <code>at</code> except there is no bounds check. If <code>i</code> is out of bounds a seg fault will likely occur. If you are unsure of whether <code>i</code> is in bounds use <code>at</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Which of elements in this subset to return. <code>i</code> must be in the range [0,<a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#aa444418a9143ec2f73bcb4df7b161563" title="The number of elements in this Subset.">size()</a>); however, no bounds check occurrs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only reference to the <code>i</code> -th element in the subset.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab79995ff6b19c717db1aa0ea34cf97e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79995ff6b19c717db1aa0ea34cf97e3">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the intersection of this with <code>rhs</code>. </p>
<p>The intersction of two sets, <img class="formulaInl" alt="$A$" src="form_4.png"/> and <img class="formulaInl" alt="$B$" src="form_6.png"/>, is the set <img class="formulaInl" alt="$C$" src="form_8.png"/> containing all elements that appear in both <img class="formulaInl" alt="$A$" src="form_4.png"/> and <img class="formulaInl" alt="$B$" src="form_6.png"/>. This function will return the intersection of itself with <code>rhs</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The set we are taking the intersection with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The intersection of this with <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>rhs</code> has a different parent set. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if a memory allocation problem occurs. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8267759ca50b480285b6f89b2a202e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8267759ca50b480285b6f89b2a202e03">&#9670;&nbsp;</a></span>operator^=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a>&amp; <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">my_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this to the intersection of itself with <code>rhs</code>. </p>
<p>The intersction of two sets, <img class="formulaInl" alt="$A$" src="form_4.png"/> and <img class="formulaInl" alt="$B$" src="form_6.png"/>, is the set <img class="formulaInl" alt="$C$" src="form_8.png"/> containing all elements that appear in both <img class="formulaInl" alt="$A$" src="form_4.png"/> and <img class="formulaInl" alt="$B$" src="form_6.png"/>. This function will set the current instance to the intersection of itself with <code>rhs</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The set we are taking the intersection with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance after setting it to the intersection of itself with <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>rhs</code> has a different parent set. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if a memory allocation problem occurs. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa444418a9143ec2f73bcb4df7b161563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa444418a9143ec2f73bcb4df7b161563">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html#a7442fe2c50e4d4fbeed21504b38e8f9c">size_type</a> <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">libchemist::set_theory::Subset</a>&lt; SetType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of elements in this <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html" title="Models a subset of a set.">Subset</a>. </p>
<p>This function will compute the cardinality (number of elements) of the subset.</p>
<dl class="section note"><dt>Note</dt><dd>This is in general <b>not</b> the same as the number or elements in the Subseted object!!!</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aee925edcede08ec92a7fccab88c89251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee925edcede08ec92a7fccab88c89251">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHSSetType , typename RHSSetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">Subset</a>&lt; LHSSetType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">Subset</a>&lt; RHSSetType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html" title="Models a subset of a set.">Subset</a> instances are different. </p>
<p>Two <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html" title="Models a subset of a set.">Subset</a> instances are equal if they are subsets of the same set and if they contain the same elements. In particular this does not place any restriction on what family of sets they belong to.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHSSetType</td><td>The type of the set <code>lhs</code> is drawn from. </td></tr>
    <tr><td class="paramname">RHSSetType</td><td>The type of the set <code>rhs</code> is drawn from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The instance on the left side of the not-equal operator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance on the right side of the not-equal operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if <code>lhs</code> is equal to <code>rhs</code> and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3e249ecd942c78f8cf49ffd6023b0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e249ecd942c78f8cf49ffd6023b0e4">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHSSetType , typename RHSSetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">Subset</a>&lt; LHSSetType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html">Subset</a>&lt; RHSSetType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html" title="Models a subset of a set.">Subset</a> instances for equality. </p>
<p>Two <a class="el" href="classlibchemist_1_1set__theory_1_1Subset.html" title="Models a subset of a set.">Subset</a> instances are equal if they are subsets of the same set and if they contain the same elements. In particular this does not place any restriction on what family of sets they belong to.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHSSetType</td><td>The type of the set <code>lhs</code> is drawn from. </td></tr>
    <tr><td class="paramname">RHSSetType</td><td>The type of the set <code>rhs</code> is drawn from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The set on the left side of the equality operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The set on the right side of the equality operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>lhs</code> is equal to <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/libchemist/set_theory/<a class="el" href="subset_8hpp_source.html">subset.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
