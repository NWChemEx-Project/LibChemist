<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libchemist: libchemist Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libchemist
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">libchemist Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The primary namespace for the libchemist library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1AOBasisSet.html">AOBasisSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1AOSpace.html">AOSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1Atom.html">Atom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for holding the details of an atomic unit.  <a href="classlibchemist_1_1Atom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1BasisSetManager.html">BasisSetManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for managing the available basis sets.  <a href="classlibchemist_1_1BasisSetManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1BasisSetMap.html">BasisSetMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for bidirectional mapping between the indices of the AOs, Shells, and atom centers that comprise a basis set.  <a href="classlibchemist_1_1BasisSetMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1CanonicalMO.html">CanonicalMO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1Center.html">Center</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1ContractedGaussian.html">ContractedGaussian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An atomic orbital resulting from a linear combination of Gaussian primitives.  <a href="classlibchemist_1_1ContractedGaussian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1ContractedGaussianView.html">ContractedGaussianView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models a reference to a <a class="el" href="classlibchemist_1_1ContractedGaussian.html" title="An atomic orbital resulting from a linear combination of Gaussian primitives. ">ContractedGaussian</a>.  <a href="classlibchemist_1_1ContractedGaussianView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1Molecule.html">Molecule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1MoleculeManager.html">MoleculeManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for storing a list of pre-built molecules.  <a href="classlibchemist_1_1MoleculeManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibchemist_1_1MoleculeStreamParser.html">MoleculeStreamParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class abstracts away the layout of a string representation of a <a class="el" href="classlibchemist_1_1Molecule.html">Molecule</a>.  <a href="structlibchemist_1_1MoleculeStreamParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1OrbitalSpace.html">OrbitalSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1OrthogonalSpace.html">OrthogonalSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1PeriodicTable.html">PeriodicTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class serving as a factory for <a class="el" href="classlibchemist_1_1Atom.html" title="A class for holding the details of an atomic unit. ">Atom</a> instances.  <a href="classlibchemist_1_1PeriodicTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1Point.html">Point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object that is associated with a point in 3-D Cartesian space.  <a href="classlibchemist_1_1Point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1PointView.html">PointView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements reference-like semantics with respect to a <a class="el" href="classlibchemist_1_1Point.html" title="An object that is associated with a point in 3-D Cartesian space. ">Point</a> instance.  <a href="classlibchemist_1_1PointView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1Primitive.html">Primitive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models a Gaussian <a class="el" href="classlibchemist_1_1Primitive.html" title="Models a Gaussian Primitive by value. ">Primitive</a> by value.  <a href="classlibchemist_1_1Primitive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1PrimitiveView.html">PrimitiveView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models a Gaussian <a class="el" href="classlibchemist_1_1Primitive.html" title="Models a Gaussian Primitive by value. ">Primitive</a> by reference.  <a href="classlibchemist_1_1PrimitiveView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1Shell.html">Shell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models a set of AOs with a common center, total angular momentum, and CGTOs.  <a href="classlibchemist_1_1Shell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1ShellView.html">ShellView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibchemist_1_1XYZParser.html">XYZParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a MoleculeParser for the xyz format.  <a href="structlibchemist_1_1XYZParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2965fd01872145b29b7b64d86e0a90a4"><td class="memItemLeft" align="right" valign="top"><a id="a2965fd01872145b29b7b64d86e0a90a4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename <a class="el" href="classlibchemist_1_1Atom.html#a1804b8965eed6ec47dc51c90211d3637">Atom::size_type</a></td></tr>
<tr class="separator:a2965fd01872145b29b7b64d86e0a90a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad426468ddae062778ade4edc0f191f9f"><td class="memItemLeft" align="right" valign="top"><a id="ad426468ddae062778ade4edc0f191f9f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>coord_type</b> = typename <a class="el" href="classlibchemist_1_1Atom.html#a72bfd6e8239cf2f0a9808ec595a67e5f">Atom::coord_type</a></td></tr>
<tr class="separator:ad426468ddae062778ade4edc0f191f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1b69adb26219fc0fe1e6d4a7c118d3"><td class="memItemLeft" align="right" valign="top"><a id="a3c1b69adb26219fc0fe1e6d4a7c118d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>name_type</b> = typename <a class="el" href="classlibchemist_1_1Atom.html#aeeb232a1eb4497caeb77d67056feb7be">Atom::name_type</a></td></tr>
<tr class="separator:a3c1b69adb26219fc0fe1e6d4a7c118d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e0f761be473d0a65ee7c414e86e39f"><td class="memItemLeft" align="right" valign="top"><a id="ae4e0f761be473d0a65ee7c414e86e39f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mass_type</b> = typename <a class="el" href="classlibchemist_1_1Atom.html#a134dd5819cfad6c6f25afd0907f14243">Atom::mass_type</a></td></tr>
<tr class="separator:ae4e0f761be473d0a65ee7c414e86e39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4378bbe70462917ac5c9d141fb5693"><td class="memTemplParams" colspan="2"><a id="a4e4378bbe70462917ac5c9d141fb5693"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e4378bbe70462917ac5c9d141fb5693"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>prim_pimpl_t</b> = <a class="el" href="classlibchemist_1_1detail___1_1PrimitivePIMPL.html">detail_::PrimitivePIMPL</a>&lt; std::remove_const_t&lt; T &gt; &gt;</td></tr>
<tr class="separator:a4e4378bbe70462917ac5c9d141fb5693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0401ac3ab2353b91c58e962f42a1a100"><td class="memTemplParams" colspan="2"><a id="a0401ac3ab2353b91c58e962f42a1a100"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0401ac3ab2353b91c58e962f42a1a100"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>point_pimpl_t</b> = <a class="el" href="classlibchemist_1_1detail___1_1PointPIMPL.html">detail_::PointPIMPL</a>&lt; std::remove_const_t&lt; T &gt; &gt;</td></tr>
<tr class="separator:a0401ac3ab2353b91c58e962f42a1a100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ead5c5869a40dcea9a4867b329eb91"><td class="memItemLeft" align="right" valign="top"><a id="a99ead5c5869a40dcea9a4867b329eb91"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ao_basis_type</b> = typename <a class="el" href="classlibchemist_1_1BasisSetManager.html#ab3a0bbdb6c89c32160e7692dcaf50b63">BasisSetManager::ao_basis_type</a></td></tr>
<tr class="separator:a99ead5c5869a40dcea9a4867b329eb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8b69cc22345a6e3ff4442e3f7bae6d"><td class="memItemLeft" align="right" valign="top"><a id="a5a8b69cc22345a6e3ff4442e3f7bae6d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = typename <a class="el" href="classlibchemist_1_1Molecule.html#aa98611e772facf918c712e10b1be384e">Molecule::value_type</a></td></tr>
<tr class="separator:a5a8b69cc22345a6e3ff4442e3f7bae6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9880ab44c2fc5e77413f365b8d9d54e"><td class="memItemLeft" align="right" valign="top"><a id="ae9880ab44c2fc5e77413f365b8d9d54e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = typename <a class="el" href="classlibchemist_1_1Molecule.html#aac96e7a78bc49e9fa02f41c00d0adab1">Molecule::reference</a></td></tr>
<tr class="separator:ae9880ab44c2fc5e77413f365b8d9d54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149fa4ad22fa407d5a0498e818374c42"><td class="memItemLeft" align="right" valign="top"><a id="a149fa4ad22fa407d5a0498e818374c42"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = typename <a class="el" href="classlibchemist_1_1Molecule.html#aefd26492c3889418c2bf32d2464ec88d">Molecule::const_reference</a></td></tr>
<tr class="separator:a149fa4ad22fa407d5a0498e818374c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dc041252f31e4b836c41fbdcde14b1"><td class="memItemLeft" align="right" valign="top"><a id="a26dc041252f31e4b836c41fbdcde14b1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = typename <a class="el" href="classlibchemist_1_1Molecule.html#ad31d8a2f6717b2dc2aa92fafb8e4f6a2">Molecule::iterator</a></td></tr>
<tr class="separator:a26dc041252f31e4b836c41fbdcde14b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc141f8e3579b7f473680f16f8ecc15a"><td class="memItemLeft" align="right" valign="top"><a id="acc141f8e3579b7f473680f16f8ecc15a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = typename <a class="el" href="classlibchemist_1_1Molecule.html#af6cf8f4313ac4507556e9c270b233936">Molecule::const_iterator</a></td></tr>
<tr class="separator:acc141f8e3579b7f473680f16f8ecc15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca2aa65a864aafdbf56928f48cf8c9f"><td class="memItemLeft" align="right" valign="top"><a id="aaca2aa65a864aafdbf56928f48cf8c9f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b> = typename <a class="el" href="classlibchemist_1_1MoleculeManager.html#a324b5768ddd414eafa63ecb0b0fb2529">MoleculeManager::key_type</a></td></tr>
<tr class="separator:aaca2aa65a864aafdbf56928f48cf8c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59972f913222c140c268ee309b8396c"><td class="memItemLeft" align="right" valign="top"><a id="ab59972f913222c140c268ee309b8396c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>action_type</b> = MoleculeStreamParser::action_type</td></tr>
<tr class="separator:ab59972f913222c140c268ee309b8396c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8de90147e7c6cf4c109705e99422c8f"><td class="memItemLeft" align="right" valign="top"><a id="ad8de90147e7c6cf4c109705e99422c8f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>data_type</b> = MoleculeStreamParser::data_type</td></tr>
<tr class="separator:ad8de90147e7c6cf4c109705e99422c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d34b2e03c37dda2a4a21775948ade21"><td class="memItemLeft" align="right" valign="top"><a id="a3d34b2e03c37dda2a4a21775948ade21"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>return_type</b> = std::map&lt; data_type, std::vector&lt; double &gt; &gt;</td></tr>
<tr class="separator:a3d34b2e03c37dda2a4a21775948ade21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46492a83d35b442c72d93009adbf0dfa"><td class="memItemLeft" align="right" valign="top"><a id="a46492a83d35b442c72d93009adbf0dfa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Molecule</b> = <a class="el" href="classlibchemist_1_1Molecule.html">libchemist::Molecule</a></td></tr>
<tr class="separator:a46492a83d35b442c72d93009adbf0dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3299ea7a6c001b890057f80a08994bb8"><td class="memItemLeft" align="right" valign="top"><a id="a3299ea7a6c001b890057f80a08994bb8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>isotope_list</b> = typename <a class="el" href="classlibchemist_1_1PeriodicTable.html#ab555d67a1fa4a5cda77751dd9344722b">PeriodicTable::isotope_list</a></td></tr>
<tr class="separator:a3299ea7a6c001b890057f80a08994bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac41cd720a0cecffcc8e0c2312aef608a"><td class="memItemLeft" align="right" valign="top"><a id="ac41cd720a0cecffcc8e0c2312aef608a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ShellType</b> { <b>cartesian</b> = 0, 
<b>pure</b> = 1
 }</td></tr>
<tr class="separator:ac41cd720a0cecffcc8e0c2312aef608a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafe295d91dc90d94b0d73e4c4b7c96d6a"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classlibchemist_1_1Atom.html">Atom</a> &amp;lhs, const <a class="el" href="classlibchemist_1_1Atom.html">Atom</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:gafe295d91dc90d94b0d73e4c4b7c96d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada191679d3e72bbd009137edfb90e436"><td class="memItemLeft" align="right" valign="top"><a id="ada191679d3e72bbd009137edfb90e436"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classlibchemist_1_1Atom.html">Atom</a> &amp;ai)</td></tr>
<tr class="separator:ada191679d3e72bbd009137edfb90e436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2995c9960f76fafb3d02b1559469de24"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classlibchemist_1_1Atom.html">Atom</a> &amp;lhs, const <a class="el" href="classlibchemist_1_1Atom.html">Atom</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:ga2995c9960f76fafb3d02b1559469de24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769f9ce616c597af84d7f55be090c692"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a769f9ce616c597af84d7f55be090c692"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibchemist.html#a769f9ce616c597af84d7f55be090c692">operator==</a> (const <a class="el" href="classlibchemist_1_1Center.html">Center</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classlibchemist_1_1Center.html">Center</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a769f9ce616c597af84d7f55be090c692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classlibchemist_1_1Center.html">Center</a> instances for equality.  <a href="#a769f9ce616c597af84d7f55be090c692">More...</a><br /></td></tr>
<tr class="separator:a769f9ce616c597af84d7f55be090c692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab180763328a7dc0ed8adb1ab2d52ff16"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab180763328a7dc0ed8adb1ab2d52ff16"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibchemist.html#ab180763328a7dc0ed8adb1ab2d52ff16">operator!=</a> (const <a class="el" href="classlibchemist_1_1Center.html">Center</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classlibchemist_1_1Center.html">Center</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab180763328a7dc0ed8adb1ab2d52ff16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classlibchemist_1_1Center.html">Center</a> instances are different.  <a href="#ab180763328a7dc0ed8adb1ab2d52ff16">More...</a><br /></td></tr>
<tr class="separator:ab180763328a7dc0ed8adb1ab2d52ff16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b4d60cba4e23af2eb557ac3c54ec3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7b4d60cba4e23af2eb557ac3c54ec3b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibchemist.html#ad7b4d60cba4e23af2eb557ac3c54ec3b">operator==</a> (const <a class="el" href="classlibchemist_1_1ContractedGaussian.html">ContractedGaussian</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classlibchemist_1_1ContractedGaussian.html">ContractedGaussian</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad7b4d60cba4e23af2eb557ac3c54ec3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classlibchemist_1_1ContractedGaussian.html" title="An atomic orbital resulting from a linear combination of Gaussian primitives. ">ContractedGaussian</a> instances for equality.  <a href="#ad7b4d60cba4e23af2eb557ac3c54ec3b">More...</a><br /></td></tr>
<tr class="separator:ad7b4d60cba4e23af2eb557ac3c54ec3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0494371276bf303957d32964a63af52"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0494371276bf303957d32964a63af52"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibchemist.html#ab0494371276bf303957d32964a63af52">operator!=</a> (const <a class="el" href="classlibchemist_1_1ContractedGaussian.html">ContractedGaussian</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classlibchemist_1_1ContractedGaussian.html">ContractedGaussian</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab0494371276bf303957d32964a63af52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classlibchemist_1_1ContractedGaussian.html" title="An atomic orbital resulting from a linear combination of Gaussian primitives. ">ContractedGaussian</a> instances are different.  <a href="#ab0494371276bf303957d32964a63af52">More...</a><br /></td></tr>
<tr class="separator:ab0494371276bf303957d32964a63af52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0384520b804de7565132950e01be017d"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibchemist.html#a0384520b804de7565132950e01be017d">l_converter</a> (char l)</td></tr>
<tr class="memdesc:a0384520b804de7565132950e01be017d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the string representation of orbital angular momentum to its actual value in a.u.  <a href="#a0384520b804de7565132950e01be017d">More...</a><br /></td></tr>
<tr class="separator:a0384520b804de7565132950e01be017d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ada164c002159a0cf14fd64f7f711cf"><td class="memTemplParams" colspan="2">template&lt;typename E1 , typename E2 , typename T &gt; </td></tr>
<tr class="memitem:a3ada164c002159a0cf14fd64f7f711cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibchemist.html#a3ada164c002159a0cf14fd64f7f711cf">operator==</a> (const <a class="el" href="classlibchemist_1_1CanonicalMO.html">CanonicalMO</a>&lt; E1, T &gt; &amp;space1, const <a class="el" href="classlibchemist_1_1CanonicalMO.html">CanonicalMO</a>&lt; E2, T &gt; &amp;space2)</td></tr>
<tr class="memdesc:a3ada164c002159a0cf14fd64f7f711cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine where two <a class="el" href="classlibchemist_1_1OrbitalSpace.html">OrbitalSpace</a> instances are equivalent.  <a href="#a3ada164c002159a0cf14fd64f7f711cf">More...</a><br /></td></tr>
<tr class="separator:a3ada164c002159a0cf14fd64f7f711cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760be23ec0143f23c88e0870d5d2a795"><td class="memTemplParams" colspan="2">template&lt;typename E1 , typename E2 , typename T &gt; </td></tr>
<tr class="memitem:a760be23ec0143f23c88e0870d5d2a795"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibchemist.html#a760be23ec0143f23c88e0870d5d2a795">operator!=</a> (const <a class="el" href="classlibchemist_1_1CanonicalMO.html">CanonicalMO</a>&lt; E1, T &gt; &amp;space1, const <a class="el" href="classlibchemist_1_1CanonicalMO.html">CanonicalMO</a>&lt; E2, T &gt; &amp;space2)</td></tr>
<tr class="memdesc:a760be23ec0143f23c88e0870d5d2a795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine where two <a class="el" href="classlibchemist_1_1OrbitalSpace.html">OrbitalSpace</a> instances are not equivalent.  <a href="#a760be23ec0143f23c88e0870d5d2a795">More...</a><br /></td></tr>
<tr class="separator:a760be23ec0143f23c88e0870d5d2a795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44ca813ffd794288b494c01dde99adc"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibchemist.html#af44ca813ffd794288b494c01dde99adc">apply_basis</a> (const std::string &amp;name, const <a class="el" href="classlibchemist_1_1Molecule.html">Molecule</a> &amp;mol, const <a class="el" href="classlibchemist_1_1BasisSetManager.html">BasisSetManager</a> &amp;man=<a class="el" href="classlibchemist_1_1BasisSetManager.html">BasisSetManager</a>())</td></tr>
<tr class="memdesc:af44ca813ffd794288b494c01dde99adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for applying a basis set to a molecule.  <a href="#af44ca813ffd794288b494c01dde99adc">More...</a><br /></td></tr>
<tr class="separator:af44ca813ffd794288b494c01dde99adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1166eb2b8559112acc3fa058ad3a610"><td class="memItemLeft" align="right" valign="top"><a id="ae1166eb2b8559112acc3fa058ad3a610"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classlibchemist_1_1Molecule.html">libchemist::Molecule</a> &amp;mol)</td></tr>
<tr class="separator:ae1166eb2b8559112acc3fa058ad3a610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa54e4b257406653c2219ab2b20ab95c6"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classlibchemist_1_1Molecule.html">Molecule</a> &amp;lhs, const <a class="el" href="classlibchemist_1_1Molecule.html">Molecule</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:gaa54e4b257406653c2219ab2b20ab95c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03ab7bf3886bd6ef9ff46b2da3a92290"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classlibchemist_1_1Molecule.html">Molecule</a> &amp;lhs, const <a class="el" href="classlibchemist_1_1Molecule.html">Molecule</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:ga03ab7bf3886bd6ef9ff46b2da3a92290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979e619200ad7348ca6254921e9d1fa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1Molecule.html">Molecule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibchemist.html#a979e619200ad7348ca6254921e9d1fa8">parse_molecule_stream</a> (std::istream &amp;is, const <a class="el" href="structlibchemist_1_1MoleculeStreamParser.html">MoleculeStreamParser</a> &amp;parser, const <a class="el" href="classlibchemist_1_1PeriodicTable.html">libchemist::PeriodicTable</a> &amp;pt)</td></tr>
<tr class="memdesc:a979e619200ad7348ca6254921e9d1fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function to call to parse a MoleculeStream.  <a href="#a979e619200ad7348ca6254921e9d1fa8">More...</a><br /></td></tr>
<tr class="separator:a979e619200ad7348ca6254921e9d1fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc5730a2f91fc3197f631cd8fb1d83e"><td class="memTemplParams" colspan="2">template&lt;typename E1 , typename E2 , typename T &gt; </td></tr>
<tr class="memitem:aafc5730a2f91fc3197f631cd8fb1d83e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibchemist.html#aafc5730a2f91fc3197f631cd8fb1d83e">operator==</a> (const <a class="el" href="classlibchemist_1_1OrbitalSpace.html">OrbitalSpace</a>&lt; E1, T &gt; &amp;space1, const <a class="el" href="classlibchemist_1_1OrbitalSpace.html">OrbitalSpace</a>&lt; E2, T &gt; &amp;space2)</td></tr>
<tr class="memdesc:aafc5730a2f91fc3197f631cd8fb1d83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine where two <a class="el" href="classlibchemist_1_1OrbitalSpace.html">OrbitalSpace</a> instances are equivalent.  <a href="#aafc5730a2f91fc3197f631cd8fb1d83e">More...</a><br /></td></tr>
<tr class="separator:aafc5730a2f91fc3197f631cd8fb1d83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6684d60eadcc0e4470c6d196d79aea"><td class="memTemplParams" colspan="2">template&lt;typename E1 , typename E2 , typename T &gt; </td></tr>
<tr class="memitem:adc6684d60eadcc0e4470c6d196d79aea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibchemist.html#adc6684d60eadcc0e4470c6d196d79aea">operator!=</a> (const <a class="el" href="classlibchemist_1_1OrbitalSpace.html">OrbitalSpace</a>&lt; E1, T &gt; &amp;space1, const <a class="el" href="classlibchemist_1_1OrbitalSpace.html">OrbitalSpace</a>&lt; E2, T &gt; &amp;space2)</td></tr>
<tr class="memdesc:adc6684d60eadcc0e4470c6d196d79aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine where two <a class="el" href="classlibchemist_1_1OrbitalSpace.html">OrbitalSpace</a> instances are not equivalent.  <a href="#adc6684d60eadcc0e4470c6d196d79aea">More...</a><br /></td></tr>
<tr class="separator:adc6684d60eadcc0e4470c6d196d79aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The primary namespace for the libchemist library. </p>
<p>All functionality of the libchemist library intended for end user consumption is defined within this namespace. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="af44ca813ffd794288b494c01dde99adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44ca813ffd794288b494c01dde99adc">&#9670;&nbsp;</a></span>apply_basis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto libchemist::apply_basis </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1Molecule.html">Molecule</a> &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1BasisSetManager.html">BasisSetManager</a> &amp;&#160;</td>
          <td class="paramname"><em>man</em> = <code><a class="el" href="classlibchemist_1_1BasisSetManager.html">BasisSetManager</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function for applying a basis set to a molecule. </p>
<p>[in] name The name of the basis set to apply </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mol</td><td>The molecule instance to apply the basis set to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">man</td><td>The <a class="el" href="classlibchemist_1_1BasisSetManager.html" title="A class for managing the available basis sets. ">BasisSetManager</a> instance to read the basis set from. Defaults to a default constructed variant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The basis set resulting from applying it to <code>mol</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to create the basis set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0384520b804de7565132950e01be017d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0384520b804de7565132950e01be017d">&#9670;&nbsp;</a></span>l_converter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t libchemist::l_converter </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the string representation of orbital angular momentum to its actual value in a.u. </p>
<p>This is a convenience function for taking a letter like: 's', 'p', 'd', or 'f' and converting it to the corresponding numerical angular momentum value (for the examples listed those values are respectively 0, 1, 2, and 3). This function is capable of mapping the first 26 values (when going in alphabetical order after 'f', 's', 'p', and 'd' are skipped the second time they would be encountered <em>e.g.</em>, it goes 'm', 'n', 'o', 'q' and not 'm', 'n', 'o', 'p', 'q'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>The string representation of the orbital angular momentum. It is assumed to be a single character, <em>i.e.</em>, l &gt; 25 is not supported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The numerical value of the orbital angular momentum in atomic units. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code>l</code> is not a letter of the English alphabet. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a760be23ec0143f23c88e0870d5d2a795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760be23ec0143f23c88e0870d5d2a795">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E1 , typename E2 , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool libchemist::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1CanonicalMO.html">CanonicalMO</a>&lt; E1, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>space1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1CanonicalMO.html">CanonicalMO</a>&lt; E2, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>space2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine where two <a class="el" href="classlibchemist_1_1OrbitalSpace.html">OrbitalSpace</a> instances are not equivalent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space1</td><td>The first instance </td></tr>
    <tr><td class="paramname">space2</td><td>The second instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the instances are not equivalent </dd></dl>

</div>
</div>
<a id="ab0494371276bf303957d32964a63af52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0494371276bf303957d32964a63af52">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool libchemist::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1ContractedGaussian.html">ContractedGaussian</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1ContractedGaussian.html">ContractedGaussian</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classlibchemist_1_1ContractedGaussian.html" title="An atomic orbital resulting from a linear combination of Gaussian primitives. ">ContractedGaussian</a> instances are different. </p>
<p>Two <a class="el" href="classlibchemist_1_1ContractedGaussian.html" title="An atomic orbital resulting from a linear combination of Gaussian primitives. ">ContractedGaussian</a> instances are considered equal if they contain the same number of primitives and if the i-th primitive of <code>lhs</code> is equal to the i-th primitive of <code>rhs</code> for all i in the range <code>[0, lhs.size())</code>. Different is defined as not equal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type used to hold the <a class="el" href="classlibchemist_1_1ContractedGaussian.html" title="An atomic orbital resulting from a linear combination of Gaussian primitives. ">ContractedGaussian</a>'s parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The instance on the left side of the operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance on the right side of the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the the two instances are equal and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to make the PIMPL for one of the <a class="el" href="classlibchemist_1_1PrimitiveView.html" title="Models a Gaussian Primitive by reference. ">PrimitiveView</a> instances. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc6684d60eadcc0e4470c6d196d79aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6684d60eadcc0e4470c6d196d79aea">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E1 , typename E2 , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool libchemist::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1OrbitalSpace.html">OrbitalSpace</a>&lt; E1, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>space1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1OrbitalSpace.html">OrbitalSpace</a>&lt; E2, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>space2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine where two <a class="el" href="classlibchemist_1_1OrbitalSpace.html">OrbitalSpace</a> instances are not equivalent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space1</td><td>The first instance </td></tr>
    <tr><td class="paramname">space2</td><td>The second instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the instances are not equivalent </dd></dl>

</div>
</div>
<a id="ab180763328a7dc0ed8adb1ab2d52ff16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab180763328a7dc0ed8adb1ab2d52ff16">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool libchemist::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1Center.html">Center</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1Center.html">Center</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classlibchemist_1_1Center.html">Center</a> instances are different. </p>
<p>Two <a class="el" href="classlibchemist_1_1Center.html">Center</a> instances are considered equal if they contain the same number of shells and if the i-th shell of <code>lhs</code> is equal to the i-th shell of <code>rhs</code> for all i in the range <code>[0, lhs.size())</code>. Different is defined as not equal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type used to hold the <a class="el" href="classlibchemist_1_1Center.html">Center</a>'s parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The instance on the left side of the operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance on the right side of the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the the two instances are equal and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to make the PIMPL for one of the <a class="el" href="classlibchemist_1_1ShellView.html">ShellView</a> instances. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ada164c002159a0cf14fd64f7f711cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ada164c002159a0cf14fd64f7f711cf">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E1 , typename E2 , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool libchemist::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1CanonicalMO.html">CanonicalMO</a>&lt; E1, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>space1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1CanonicalMO.html">CanonicalMO</a>&lt; E2, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>space2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine where two <a class="el" href="classlibchemist_1_1OrbitalSpace.html">OrbitalSpace</a> instances are equivalent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space1</td><td>The first instance </td></tr>
    <tr><td class="paramname">space2</td><td>The second instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the instances are equivalent </dd></dl>

</div>
</div>
<a id="ad7b4d60cba4e23af2eb557ac3c54ec3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b4d60cba4e23af2eb557ac3c54ec3b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool libchemist::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1ContractedGaussian.html">ContractedGaussian</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1ContractedGaussian.html">ContractedGaussian</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classlibchemist_1_1ContractedGaussian.html" title="An atomic orbital resulting from a linear combination of Gaussian primitives. ">ContractedGaussian</a> instances for equality. </p>
<p>Two <a class="el" href="classlibchemist_1_1ContractedGaussian.html" title="An atomic orbital resulting from a linear combination of Gaussian primitives. ">ContractedGaussian</a> instances are considered equal if they contain the same number of primitives and if the i-th primitive of <code>lhs</code> is equal to the i-th primitive of <code>rhs</code> for all i in the range <code>[0, lhs.size())</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type used to hold the <a class="el" href="classlibchemist_1_1ContractedGaussian.html" title="An atomic orbital resulting from a linear combination of Gaussian primitives. ">ContractedGaussian</a>'s parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The instance on the left side of the operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance on the right side of the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the the two instances are equal and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to make the PIMPL for one of the <a class="el" href="classlibchemist_1_1PrimitiveView.html" title="Models a Gaussian Primitive by reference. ">PrimitiveView</a> instances. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aafc5730a2f91fc3197f631cd8fb1d83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc5730a2f91fc3197f631cd8fb1d83e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E1 , typename E2 , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool libchemist::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1OrbitalSpace.html">OrbitalSpace</a>&lt; E1, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>space1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1OrbitalSpace.html">OrbitalSpace</a>&lt; E2, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>space2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine where two <a class="el" href="classlibchemist_1_1OrbitalSpace.html">OrbitalSpace</a> instances are equivalent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space1</td><td>The first instance </td></tr>
    <tr><td class="paramname">space2</td><td>The second instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the instances are equivalent </dd></dl>

</div>
</div>
<a id="a769f9ce616c597af84d7f55be090c692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769f9ce616c597af84d7f55be090c692">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool libchemist::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1Center.html">Center</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1Center.html">Center</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classlibchemist_1_1Center.html">Center</a> instances for equality. </p>
<p>Two <a class="el" href="classlibchemist_1_1Center.html">Center</a> instances are considered equal if they contain the same number of shells and if the i-th shell of <code>lhs</code> is equal to the i-th shell of <code>rhs</code> for all i in the range <code>[0, lhs.size())</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type used to hold the <a class="el" href="classlibchemist_1_1Center.html">Center</a>'s parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The instance on the left side of the operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance on the right side of the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the the two instances are equal and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to make the PIMPL for one of the <a class="el" href="classlibchemist_1_1ShellView.html">ShellView</a> instances. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a979e619200ad7348ca6254921e9d1fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979e619200ad7348ca6254921e9d1fa8">&#9670;&nbsp;</a></span>parse_molecule_stream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1Molecule.html">Molecule</a> libchemist::parse_molecule_stream </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlibchemist_1_1MoleculeStreamParser.html">MoleculeStreamParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1PeriodicTable.html">libchemist::PeriodicTable</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function to call to parse a MoleculeStream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is</td><td>An input stream containing a string representation of a <a class="el" href="classlibchemist_1_1Molecule.html">Molecule</a> instance in a format the parser understands. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>The parser to be used to parse the input stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pt</td><td>The definition of the <a class="el" href="classlibchemist_1_1PeriodicTable.html" title="A class serving as a factory for Atom instances. ">PeriodicTable</a> instance we're using </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classlibchemist_1_1Molecule.html">Molecule</a> instance represented in the input stream. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the charge and multiplicity of the molecule is in consistent. Weak throw guarantee for <code>is</code> and strong throw for all other parameters. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to allocate the new molecule. Weak throw guarantee for <code>is</code> and strong throw for all other parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
