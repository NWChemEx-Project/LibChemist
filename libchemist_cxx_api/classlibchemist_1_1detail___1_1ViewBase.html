<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libchemist: libchemist::detail_::ViewBase&lt; is_const, AliasedType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libchemist
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibchemist.html">libchemist</a></li><li class="navelem"><b>detail_</b></li><li class="navelem"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">ViewBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classlibchemist_1_1detail___1_1ViewBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libchemist::detail_::ViewBase&lt; is_const, AliasedType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Code factorization for implementing a view of an object.  
 <a href="classlibchemist_1_1detail___1_1ViewBase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="view__base_8hpp_source.html">view_base.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a405d10bba5cd32421f83c5cbf244b8e6"><td class="memItemLeft" align="right" valign="top"><a id="a405d10bba5cd32421f83c5cbf244b8e6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#a405d10bba5cd32421f83c5cbf244b8e6">aliased_type</a> = AliasedType</td></tr>
<tr class="memdesc:a405d10bba5cd32421f83c5cbf244b8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the instance holding the aliased state, for meta-programming. <br /></td></tr>
<tr class="separator:a405d10bba5cd32421f83c5cbf244b8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aef243320b127600aecea0a5154e80c94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#aef243320b127600aecea0a5154e80c94">ViewBase</a> (AliasedType <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#a56c2ddb3170fc1a0afa2620a4a563302">pimpl</a>)</td></tr>
<tr class="memdesc:aef243320b127600aecea0a5154e80c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html" title="Code factorization for implementing a view of an object. ">ViewBase</a> that wraps the provided aliasing instance.  <a href="#aef243320b127600aecea0a5154e80c94">More...</a><br /></td></tr>
<tr class="separator:aef243320b127600aecea0a5154e80c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e050f41d30d52a3e2b540770ee60e13"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#a2e050f41d30d52a3e2b540770ee60e13">ViewBase</a> (const <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">my_type</a> &amp;rhs) noexcept=default</td></tr>
<tr class="memdesc:a2e050f41d30d52a3e2b540770ee60e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a new <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html" title="Code factorization for implementing a view of an object. ">ViewBase</a> that aliases the same state as <code>rhs</code>.  <a href="#a2e050f41d30d52a3e2b540770ee60e13">More...</a><br /></td></tr>
<tr class="separator:a2e050f41d30d52a3e2b540770ee60e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61fff28f93a9b39b0259ac149f24e1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">ViewBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#ab61fff28f93a9b39b0259ac149f24e1c">operator=</a> (const <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">my_type</a> &amp;rhs) noexcept=default</td></tr>
<tr class="memdesc:ab61fff28f93a9b39b0259ac149f24e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the current <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html" title="Code factorization for implementing a view of an object. ">ViewBase</a> alias the same state as <code>rhs</code>.  <a href="#ab61fff28f93a9b39b0259ac149f24e1c">More...</a><br /></td></tr>
<tr class="separator:ab61fff28f93a9b39b0259ac149f24e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6852c550e0eb68db955639fa06834d3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#a6852c550e0eb68db955639fa06834d3f">ViewBase</a> (<a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">my_type</a> &amp;&amp;rhs) noexcept=default</td></tr>
<tr class="memdesc:a6852c550e0eb68db955639fa06834d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html" title="Code factorization for implementing a view of an object. ">ViewBase</a> which takes over ownership of <code>rhs's</code> state.  <a href="#a6852c550e0eb68db955639fa06834d3f">More...</a><br /></td></tr>
<tr class="separator:a6852c550e0eb68db955639fa06834d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bf250265c354bfdd2c59fbc536e841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">ViewBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#ae5bf250265c354bfdd2c59fbc536e841">operator=</a> (<a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">my_type</a> &amp;&amp;rhs) noexcept=default</td></tr>
<tr class="memdesc:ae5bf250265c354bfdd2c59fbc536e841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the current instance's aliased state with that of <code>rhs</code>.  <a href="#ae5bf250265c354bfdd2c59fbc536e841">More...</a><br /></td></tr>
<tr class="separator:ae5bf250265c354bfdd2c59fbc536e841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6718a08ed7d5e27874bfb2558803638"><td class="memItemLeft" align="right" valign="top"><a id="af6718a08ed7d5e27874bfb2558803638"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#af6718a08ed7d5e27874bfb2558803638">~ViewBase</a> () noexcept=default</td></tr>
<tr class="memdesc:af6718a08ed7d5e27874bfb2558803638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default polymorphic dtor. <br /></td></tr>
<tr class="separator:af6718a08ed7d5e27874bfb2558803638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564c30ba151823d6b8c6a65ed369ddac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#a564c30ba151823d6b8c6a65ed369ddac">operator const_alias</a> () const noexcept</td></tr>
<tr class="memdesc:a564c30ba151823d6b8c6a65ed369ddac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables implicit conversion to a read-only instance of the aliased type.  <a href="#a564c30ba151823d6b8c6a65ed369ddac">More...</a><br /></td></tr>
<tr class="separator:a564c30ba151823d6b8c6a65ed369ddac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cab8b318e87c5fe3ca1c8a4c1985ae7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#a7cab8b318e87c5fe3ca1c8a4c1985ae7">operator==</a> (const_alias rhs) const</td></tr>
<tr class="memdesc:a7cab8b318e87c5fe3ca1c8a4c1985ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows comparing views to the underlying instance.  <a href="#a7cab8b318e87c5fe3ca1c8a4c1985ae7">More...</a><br /></td></tr>
<tr class="separator:a7cab8b318e87c5fe3ca1c8a4c1985ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c747c1629e75752ea8741e11a0c4be"><td class="memTemplParams" colspan="2">template&lt;bool rhs_const&gt; </td></tr>
<tr class="memitem:a64c747c1629e75752ea8741e11a0c4be"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#a64c747c1629e75752ea8741e11a0c4be">operator==</a> (const <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">other_base</a>&lt; rhs_const &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a64c747c1629e75752ea8741e11a0c4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows comparing to other views.  <a href="#a64c747c1629e75752ea8741e11a0c4be">More...</a><br /></td></tr>
<tr class="separator:a64c747c1629e75752ea8741e11a0c4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc70fc3e40c50cdf48b613ca5e224d92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#afc70fc3e40c50cdf48b613ca5e224d92">operator!=</a> (const_alias rhs) const</td></tr>
<tr class="memdesc:afc70fc3e40c50cdf48b613ca5e224d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows comparing views to the underlying instance.  <a href="#afc70fc3e40c50cdf48b613ca5e224d92">More...</a><br /></td></tr>
<tr class="separator:afc70fc3e40c50cdf48b613ca5e224d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a462e323b70245061adb0570d157d88"><td class="memTemplParams" colspan="2">template&lt;bool rhs_const&gt; </td></tr>
<tr class="memitem:a6a462e323b70245061adb0570d157d88"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#a6a462e323b70245061adb0570d157d88">operator!=</a> (const <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">other_base</a>&lt; rhs_const &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a6a462e323b70245061adb0570d157d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows comparing to other views.  <a href="#a6a462e323b70245061adb0570d157d88">More...</a><br /></td></tr>
<tr class="separator:a6a462e323b70245061adb0570d157d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a56c2ddb3170fc1a0afa2620a4a563302"><td class="memItemLeft" align="right" valign="top">alias_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#a56c2ddb3170fc1a0afa2620a4a563302">pimpl</a> () noexcept</td></tr>
<tr class="memdesc:a56c2ddb3170fc1a0afa2620a4a563302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a (possibly) read-/write-able reference to the wrapped instance.  <a href="#a56c2ddb3170fc1a0afa2620a4a563302">More...</a><br /></td></tr>
<tr class="separator:a56c2ddb3170fc1a0afa2620a4a563302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869e4903db1ef7502744c65d048217e4"><td class="memItemLeft" align="right" valign="top">const_alias&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#a869e4903db1ef7502744c65d048217e4">pimpl</a> () const noexcept</td></tr>
<tr class="memdesc:a869e4903db1ef7502744c65d048217e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only reference to the wrapped instance.  <a href="#a869e4903db1ef7502744c65d048217e4">More...</a><br /></td></tr>
<tr class="separator:a869e4903db1ef7502744c65d048217e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a96363b1a2f2dfb56aa36e5fa7db38218"><td class="memItemLeft" align="right" valign="top">VIEW_BASE_TEMPLATE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#a96363b1a2f2dfb56aa36e5fa7db38218">operator==</a> (const AliasedType&lt; std::remove_cv_t&lt; T &gt;&gt; &amp;lhs, const VIEW_BASE_TYPE &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a96363b1a2f2dfb56aa36e5fa7db38218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the type aliased by a view to be on the left side of a comparison with a view.  <a href="#a96363b1a2f2dfb56aa36e5fa7db38218">More...</a><br /></td></tr>
<tr class="separator:a96363b1a2f2dfb56aa36e5fa7db38218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f38156249cb45e714318f0d8d105f4"><td class="memItemLeft" align="right" valign="top">VIEW_BASE_TEMPLATE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#ac3f38156249cb45e714318f0d8d105f4">operator!=</a> (const AliasedType&lt; std::remove_cv_t&lt; T &gt;&gt; &amp;lhs, const VIEW_BASE_TYPE &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac3f38156249cb45e714318f0d8d105f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the type aliased by a view to be on the left side of a comparison with a view.  <a href="#ac3f38156249cb45e714318f0d8d105f4">More...</a><br /></td></tr>
<tr class="separator:ac3f38156249cb45e714318f0d8d105f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;bool is_const, typename AliasedType&gt;<br />
class libchemist::detail_::ViewBase&lt; is_const, AliasedType &gt;</h3>

<p>Code factorization for implementing a view of an object. </p>
<p>Views allow us to alias the state of an object and "view" it as if it had a specific API. The view encapsulates the conversion logic. In LibChemist we rely on the PIMPL idiom to decouple the API from the state/implementation. A natural way to encapsulate the conversion logic is to use different PIMPLs for owning vs. aliasing. Say we have a class <code>A</code> that is implemented in terms of an abstract base class <code>Base</code> and that we have two PIMPLs <code>Own</code> and <code>Alias</code>, which derive from <code>Base</code> such that <code>Own</code> implements <code>A</code> using memory it owns and <code>Alias</code> implements <code>A</code> using memory it aliases. Since <code>A</code> ultimately stores the <code>Own</code> or <code>Alias</code> instance via the common base class <code>Base</code>, the user has no way of knowing whether <code>A</code> owns or aliases its memory. This can lead to nasty side effects where an aliased object is accidentally modified when the user intents to only modify the <code>A</code> instance.</p>
<p>The <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html" title="Code factorization for implementing a view of an object. ">ViewBase</a> class represents code factorization for implementing a view by wrapping an aliasing instance. The use of separate class (as opposed to say templating <code>A</code> above on <code>Own</code> vs <code>Alias</code>) allows us to easily change the behavior of the view vs. the object. In particular the object <code>A</code> should have value semantics regardless of whether it aliases or owns its state (i.e. copying <code>A</code> should <em>always</em> result in a deep copy). On the other hand views are akin to other aliasing types such as iterators, pointers, or references so copying should be shallow. While it is possible to do this with template specialization and/or meta-template programming, maintaining two class hierarchies is ultimately easier to maintain.</p>
<p>Usage: Derive from this class and call <code><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#a56c2ddb3170fc1a0afa2620a4a563302" title="Returns a (possibly) read-/write-able reference to the wrapped instance. ">pimpl()</a></code> to get the instance that contains the aliased data. This class will automatically take care of const-correctness for your dervied class, so just use the result of the <code><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#a56c2ddb3170fc1a0afa2620a4a563302" title="Returns a (possibly) read-/write-able reference to the wrapped instance. ">pimpl()</a></code> function as is.</p>
<p>As a design note, the instance of <code>A</code> that aliases the data is owned by this class so as to facilitate shallow copying <code><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html" title="Code factorization for implementing a view of an object. ">ViewBase</a></code> instances without needing to know more about the API of <code>A</code> (in particular this allows <code>A</code> to use its copy ctor for deep copies).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">is_const</td><td>In order to ensure we get the const-correctness of the view right we need to know if the view should be read-only. The <code>is_const</code> template non-type parameter should be set to <code>true</code> if the resulting view is read-only and <code>false</code> otherwise.</td></tr>
    <tr><td class="paramname">AliasedType</td><td>The class <code>A</code> in the description above. It is the type of the class that holds the aliasing PIMPL. We ultimately assume that <code>AliasedType</code> is moveable and can be compared via <code>operator==</code>. <code>AliasedType</code> should be an unqualified type. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aef243320b127600aecea0a5154e80c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef243320b127600aecea0a5154e80c94">&#9670;&nbsp;</a></span>ViewBase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_const, typename AliasedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">libchemist::detail_::ViewBase</a>&lt; is_const, AliasedType &gt;::<a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">ViewBase</a> </td>
          <td>(</td>
          <td class="paramtype">AliasedType&#160;</td>
          <td class="paramname"><em>pimpl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html" title="Code factorization for implementing a view of an object. ">ViewBase</a> that wraps the provided aliasing instance. </p>
<p>This is the primary ctor for this class. It takes the instance which contains the aliased state. This instance's lifetime is ultimately coupled to this view and all copies of this view.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pimpl</td><td>The instance aliasing the state. Since the instance lives in this class you most likely will want to move the instance into this class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if making the shared_ptr fails. Strong throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity: constant </p>

</div>
</div>
<a id="a2e050f41d30d52a3e2b540770ee60e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e050f41d30d52a3e2b540770ee60e13">&#9670;&nbsp;</a></span>ViewBase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_const, typename AliasedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">libchemist::detail_::ViewBase</a>&lt; is_const, AliasedType &gt;::<a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">ViewBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">my_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a new <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html" title="Code factorization for implementing a view of an object. ">ViewBase</a> that aliases the same state as <code>rhs</code>. </p>
<p><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html" title="Code factorization for implementing a view of an object. ">ViewBase</a> instances ultimately have pointer semantics, thus this ctor will create a new <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html" title="Code factorization for implementing a view of an object. ">ViewBase</a> instance, which contains a shared_ptr to the same implementing instance as <code>rhs</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance containing the state we are shallow copying.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<p>complexity: constant </p>

</div>
</div>
<a id="a6852c550e0eb68db955639fa06834d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6852c550e0eb68db955639fa06834d3f">&#9670;&nbsp;</a></span>ViewBase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_const, typename AliasedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">libchemist::detail_::ViewBase</a>&lt; is_const, AliasedType &gt;::<a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">ViewBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">my_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html" title="Code factorization for implementing a view of an object. ">ViewBase</a> which takes over ownership of <code>rhs's</code> state. </p>
<p>This ctor can be used to create a new <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html" title="Code factorization for implementing a view of an object. ">ViewBase</a> instance which aliases the same state as <code>rhs</code>. Unlike the copy ctor, after this ctor is called <code>rhs</code> will no longer alias the state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>The instance whose aliased state is being taken. After this function <code>rhs</code> will not alias any state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity constant. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a564c30ba151823d6b8c6a65ed369ddac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564c30ba151823d6b8c6a65ed369ddac">&#9670;&nbsp;</a></span>operator const_alias()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_const, typename AliasedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">libchemist::detail_::ViewBase</a>&lt; is_const, AliasedType &gt;::operator const_alias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables implicit conversion to a read-only instance of the aliased type. </p>
<p>If a user writes a function that needs to read data from a class, they likely do not want to overload it for a view of that class too. This conversion allows our view to be used as a read-only instance of that class. Since the resulting reference is read-only the aliasing nature of this instance is irrelevant and can be safely ignored by the function. This conversion also comes in to play when the user wants to break the aliasing. There it can be used to trigger the copy ctor of the wrapped instance.</p>
<dl class="section return"><dt>Returns</dt><dd>A read-only reference to the instance storing the aliased state.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity: Constant. </p>

</div>
</div>
<a id="afc70fc3e40c50cdf48b613ca5e224d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc70fc3e40c50cdf48b613ca5e224d92">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_const, typename AliasedType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">libchemist::detail_::ViewBase</a>&lt; is_const, AliasedType &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const_alias&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows comparing views to the underlying instance. </p>
<p>This comparison operator will compare the state aliased by the wrapped instance to the state of <code>rhs</code>. The actual comparison relies on <code>AliasedType::operator==</code> and therefore adopts its definition of equality. This function negates the result of the equality comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the wrapped instance compares equal to <code>rhs</code> and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the wrapped instance's operator== throws. Same throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity: Same as AliasedType::operator== </p>

</div>
</div>
<a id="a6a462e323b70245061adb0570d157d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a462e323b70245061adb0570d157d88">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_const, typename AliasedType&gt; </div>
<div class="memtemplate">
template&lt;bool rhs_const&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">libchemist::detail_::ViewBase</a>&lt; is_const, AliasedType &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">other_base</a>&lt; rhs_const &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows comparing to other views. </p>
<p>This comparison operator will compare the state aliased by the wrapped instance to the state wrapped by <code>rhs</code>. The actual comparison relies on <code>AliasedType::operator==</code> and therefore adopts its definition of equality. This function simply negates the result of the equality comparison.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rhs_const</td><td>Whether or not <code>rhs</code> is a read-only view.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the wrapped instance compares equal to the instance wrapped by <code>rhs</code> and truee otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the wrapped instance's operator== throws. Same throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity: Same as AliasedType::operator== </p>

</div>
</div>
<a id="ab61fff28f93a9b39b0259ac149f24e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61fff28f93a9b39b0259ac149f24e1c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_const, typename AliasedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">ViewBase</a>&amp; <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">libchemist::detail_::ViewBase</a>&lt; is_const, AliasedType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">my_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the current <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html" title="Code factorization for implementing a view of an object. ">ViewBase</a> alias the same state as <code>rhs</code>. </p>
<p>This function will make the current <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html" title="Code factorization for implementing a view of an object. ">ViewBase</a> instance alias the same state as <code>rhs</code>. The state that the current instance was aliasing before this operation will be freed if the reference count goes to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html" title="Code factorization for implementing a view of an object. ">ViewBase</a> whose instance should be aliased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance after making it alias <code>rhs's</code> state. </dd></dl>

</div>
</div>
<a id="ae5bf250265c354bfdd2c59fbc536e841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bf250265c354bfdd2c59fbc536e841">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_const, typename AliasedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">ViewBase</a>&amp; <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">libchemist::detail_::ViewBase</a>&lt; is_const, AliasedType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">my_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the current instance's aliased state with that of <code>rhs</code>. </p>
<p>This function will cause the current instance to use the same aliasing instance as <code>rhs</code>. After this operation the state originally aliased by this instance have its reference count decreased by 1. Similarly <code>rhs</code> will no longer alias any state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>The instance whose aliased state is being transferred to this instance. After this function <code>rhs</code> will no longer alias any state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance, but now containing <code>rhs's</code> aliased state.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>no throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity: constant. </p>

</div>
</div>
<a id="a7cab8b318e87c5fe3ca1c8a4c1985ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cab8b318e87c5fe3ca1c8a4c1985ae7">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_const, typename AliasedType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">libchemist::detail_::ViewBase</a>&lt; is_const, AliasedType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const_alias&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows comparing views to the underlying instance. </p>
<p>This comparison operator will compare the state aliased by the wrapped instance to the state of <code>rhs</code>. The actual comparison relies on <code>AliasedType::operator==</code> and therefore adopts its definition of equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the wrapped instance compares equal to <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the wrapped instance's operator== throws. Same throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity: Same as AliasedType::operator== </p>

</div>
</div>
<a id="a64c747c1629e75752ea8741e11a0c4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c747c1629e75752ea8741e11a0c4be">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_const, typename AliasedType&gt; </div>
<div class="memtemplate">
template&lt;bool rhs_const&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">libchemist::detail_::ViewBase</a>&lt; is_const, AliasedType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">other_base</a>&lt; rhs_const &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows comparing to other views. </p>
<p>This comparison operator will compare the state aliased by the wrapped instance to the state wrapped by <code>rhs</code>. The actual comparison relies on <code>AliasedType::operator==</code> and therefore adopts its definition of equality.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rhs_const</td><td>Whether or not <code>rhs</code> is a read-only view.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the wrapped instance compares equal to the instance wrapped by <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the wrapped instance's operator== throws. Same throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity: Same as AliasedType::operator== </p>

</div>
</div>
<a id="a56c2ddb3170fc1a0afa2620a4a563302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c2ddb3170fc1a0afa2620a4a563302">&#9670;&nbsp;</a></span>pimpl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_const, typename AliasedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">alias_reference <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">libchemist::detail_::ViewBase</a>&lt; is_const, AliasedType &gt;::pimpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a (possibly) read-/write-able reference to the wrapped instance. </p>
<p>This function is meant to be used by the derived class to get the instance which holds the aliased data. Basic Template meta-programming will automatically take care of the const-ness of the return for you. In particular if this view is read-only (i.e. <code>is_const</code> is true) then you will get back a read-only reference, even though this is not the const version of <code><a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html#a56c2ddb3170fc1a0afa2620a4a563302" title="Returns a (possibly) read-/write-able reference to the wrapped instance. ">pimpl()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A (possibly) read-/write-able reference to the wrapped instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity: Constant. </p>

</div>
</div>
<a id="a869e4903db1ef7502744c65d048217e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869e4903db1ef7502744c65d048217e4">&#9670;&nbsp;</a></span>pimpl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_const, typename AliasedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_alias <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html">libchemist::detail_::ViewBase</a>&lt; is_const, AliasedType &gt;::pimpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only reference to the wrapped instance. </p>
<p>This function is meant to be used by the derived class to get the instance which holds the aliased data. The returned instance is always read-only.</p>
<dl class="section return"><dt>Returns</dt><dd>A read-only reference to the wrapped instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity: Constant. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ac3f38156249cb45e714318f0d8d105f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f38156249cb45e714318f0d8d105f4">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_const, typename AliasedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VIEW_BASE_TEMPLATE bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const AliasedType&lt; std::remove_cv_t&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VIEW_BASE_TYPE &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows the type aliased by a view to be on the left side of a comparison with a view. </p>
<p>This function ensures that <code>aliased_type != view</code> works. This function ultimately works by negating <code>lhs == rhs</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The cv-qualified type used for the parameters in the view </td></tr>
    <tr><td class="paramname">AliasedType</td><td>The class the view implements an alias of </td></tr>
    <tr><td class="paramname">ViewType</td><td>The derived class <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html" title="Code factorization for implementing a view of an object. ">ViewBase</a> is implementing</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The instance on the left-side of the operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance on the right-side of the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the aliased type's operator== returns true and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96363b1a2f2dfb56aa36e5fa7db38218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96363b1a2f2dfb56aa36e5fa7db38218">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_const, typename AliasedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VIEW_BASE_TEMPLATE bool operator== </td>
          <td>(</td>
          <td class="paramtype">const AliasedType&lt; std::remove_cv_t&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VIEW_BASE_TYPE &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows the type aliased by a view to be on the left side of a comparison with a view. </p>
<p>This function ensures that <code>aliased_type == view</code> works. This function ultimately works by calling <code>rhs == lhs</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The cv-qualified type used for the parameters in the view </td></tr>
    <tr><td class="paramname">AliasedType</td><td>The class the view implements an alias of </td></tr>
    <tr><td class="paramname">ViewType</td><td>The derived class <a class="el" href="classlibchemist_1_1detail___1_1ViewBase.html" title="Code factorization for implementing a view of an object. ">ViewBase</a> is implementing</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The instance on the left-side of the operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance on the right-side of the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the aliased type's operator== returns true and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libchemist/detail_/<a class="el" href="view__base_8hpp_source.html">view_base.hpp</a></li>
<li>libchemist/basis_set/detail_/<a class="el" href="ao__basis__view__base_8hpp_source.html">ao_basis_view_base.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
