<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libchemist: libchemist::tensor Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libchemist
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibchemist.html">libchemist</a></li><li class="navelem"><a class="el" href="namespacelibchemist_1_1tensor.html">tensor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">libchemist::tensor Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>tensor_wrapper.ipp  
<a href="namespacelibchemist_1_1tensor.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1Allocator.html">Allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstracts away the details of how the <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a>'s internal tensor is formed.  <a href="classlibchemist_1_1tensor_1_1Allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibchemist_1_1tensor_1_1NDInitializerListTraits.html">NDInitializerListTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class for an <code>N</code> -dimensional initializer list of type <code>T</code>.  <a href="structlibchemist_1_1tensor_1_1NDInitializerListTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibchemist_1_1tensor_1_1NDInitializerListTraits_3_01T_00_010ul_01_4.html">NDInitializerListTraits&lt; T, 0ul &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structlibchemist_1_1tensor_1_1NDInitializerListTraits.html" title="Traits class for an N -dimensional initializer list of type T.">NDInitializerListTraits</a> for a rank 0 tensor.  <a href="structlibchemist_1_1tensor_1_1NDInitializerListTraits_3_01T_00_010ul_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1OneBigTile.html">OneBigTile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classlibchemist_1_1tensor_1_1Allocator.html" title="Abstracts away the details of how the TensorWrapper&#39;s internal tensor is formed.">Allocator</a> which puts all the elements in one big tile.  <a href="classlibchemist_1_1tensor_1_1OneBigTile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1SingleElementTiles.html">SingleElementTiles</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An allocator where every tile is a single element.  <a href="classlibchemist_1_1tensor_1_1SingleElementTiles.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibchemist_1_1tensor_1_1TensorTraits.html">TensorTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template for determining the types associated with a tensor type.  <a href="structlibchemist_1_1tensor_1_1TensorTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibchemist_1_1tensor_1_1TensorTraits_3_01const_01TA_1_1DistArray_3_01TileType_00_01PolicyType_01_4_01_4.html">TensorTraits&lt; const TA::DistArray&lt; TileType, PolicyType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes <a class="el" href="structlibchemist_1_1tensor_1_1TensorTraits.html" title="Primary template for determining the types associated with a tensor type.">TensorTraits</a> for a TiledArray tensor.  <a href="structlibchemist_1_1tensor_1_1TensorTraits_3_01const_01TA_1_1DistArray_3_01TileType_00_01PolicyType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibchemist_1_1tensor_1_1TensorTraits_3_01TA_1_1DistArray_3_01TileType_00_01PolicyType_01_4_01_4.html">TensorTraits&lt; TA::DistArray&lt; TileType, PolicyType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes <a class="el" href="structlibchemist_1_1tensor_1_1TensorTraits.html" title="Primary template for determining the types associated with a tensor type.">TensorTraits</a> for a TiledArray tensor.  <a href="structlibchemist_1_1tensor_1_1TensorTraits_3_01TA_1_1DistArray_3_01TileType_00_01PolicyType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fundamental type for wrapping tensors.  <a href="classlibchemist_1_1tensor_1_1TensorWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afba6ea4fa9d01cd5092901c75f02f06b"><td class="memItemLeft" align="right" valign="top"><a id="afba6ea4fa9d01cd5092901c75f02f06b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>tensor</b> = <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a></td></tr>
<tr class="separator:afba6ea4fa9d01cd5092901c75f02f06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c21705ae51ef1477068a6d3bb31236"><td class="memItemLeft" align="right" valign="top"><a id="a83c21705ae51ef1477068a6d3bb31236"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TWrapper</b> = <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a></td></tr>
<tr class="separator:a83c21705ae51ef1477068a6d3bb31236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579a07e3c1f3659a44d4fd00d8e2a04d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = void&gt; </td></tr>
<tr class="memitem:a579a07e3c1f3659a44d4fd00d8e2a04d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#a579a07e3c1f3659a44d4fd00d8e2a04d">enable_if_expression_t</a> = std::enable_if_t&lt; is_expression_v&lt; T &gt;, U &gt;</td></tr>
<tr class="memdesc:a579a07e3c1f3659a44d4fd00d8e2a04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to enable a function via SFINAE when <code>T</code> is part of the expression layer.  <a href="namespacelibchemist_1_1tensor.html#a579a07e3c1f3659a44d4fd00d8e2a04d">More...</a><br /></td></tr>
<tr class="separator:a579a07e3c1f3659a44d4fd00d8e2a04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee90ba7a7bc6dae8651be8089bd1f749"><td class="memTemplParams" colspan="2">template&lt;typename TensorVariant &gt; </td></tr>
<tr class="memitem:aee90ba7a7bc6dae8651be8089bd1f749"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#aee90ba7a7bc6dae8651be8089bd1f749">labeled_variant_t</a> = typename <a class="el" href="structlibchemist_1_1tensor_1_1detail___1_1LabeledVariant.html">detail_::LabeledVariant</a>&lt; TensorVariant &gt;::type</td></tr>
<tr class="memdesc:aee90ba7a7bc6dae8651be8089bd1f749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public API for getting a variant of labeled tensors.  <a href="namespacelibchemist_1_1tensor.html#aee90ba7a7bc6dae8651be8089bd1f749">More...</a><br /></td></tr>
<tr class="separator:aee90ba7a7bc6dae8651be8089bd1f749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1310338e85cde7e70e25124cc7d4f1"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a6e1310338e85cde7e70e25124cc7d4f1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#a6e1310338e85cde7e70e25124cc7d4f1">n_d_initializer_list_t</a> = typename <a class="el" href="structlibchemist_1_1tensor_1_1NDInitializerListTraits.html">NDInitializerListTraits</a>&lt; T, N &gt;::type</td></tr>
<tr class="memdesc:a6e1310338e85cde7e70e25124cc7d4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience typedef of the initializer_list for a rank <code>N</code> tensor of scalars of type <code>T</code>.  <a href="namespacelibchemist_1_1tensor.html#a6e1310338e85cde7e70e25124cc7d4f1">More...</a><br /></td></tr>
<tr class="separator:a6e1310338e85cde7e70e25124cc7d4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480b685722fd9de8442257ab458b180e"><td class="memTemplParams" colspan="2">template&lt;typename LType , typename RType &gt; </td></tr>
<tr class="memitem:a480b685722fd9de8442257ab458b180e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#a480b685722fd9de8442257ab458b180e">add_expr_t</a> = decltype(std::declval&lt; LType &gt;()+std::declval&lt; RType &gt;())</td></tr>
<tr class="memdesc:a480b685722fd9de8442257ab458b180e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the type that results from adding two tensors together.  <a href="namespacelibchemist_1_1tensor.html#a480b685722fd9de8442257ab458b180e">More...</a><br /></td></tr>
<tr class="separator:a480b685722fd9de8442257ab458b180e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5e2028deb47d3c422f76a7fa70a3b4"><td class="memTemplParams" colspan="2">template&lt;typename LType , typename RType &gt; </td></tr>
<tr class="memitem:a5e5e2028deb47d3c422f76a7fa70a3b4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#a5e5e2028deb47d3c422f76a7fa70a3b4">subt_expr_t</a> = decltype(std::declval&lt; LType &gt;() - std::declval&lt; RType &gt;())</td></tr>
<tr class="memdesc:a5e5e2028deb47d3c422f76a7fa70a3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the type that results from subtracting two tensors.  <a href="namespacelibchemist_1_1tensor.html#a5e5e2028deb47d3c422f76a7fa70a3b4">More...</a><br /></td></tr>
<tr class="separator:a5e5e2028deb47d3c422f76a7fa70a3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafb390cd0cbb43a4309781a27bd24bf"><td class="memTemplParams" colspan="2">template&lt;typename LType , typename RType &gt; </td></tr>
<tr class="memitem:afafb390cd0cbb43a4309781a27bd24bf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#afafb390cd0cbb43a4309781a27bd24bf">mult_expr_t</a> = decltype(std::declval&lt; LType &gt;() *std::declval&lt; RType &gt;())</td></tr>
<tr class="memdesc:afafb390cd0cbb43a4309781a27bd24bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the type that results from multiplying two tensors together.  <a href="namespacelibchemist_1_1tensor.html#afafb390cd0cbb43a4309781a27bd24bf">More...</a><br /></td></tr>
<tr class="separator:afafb390cd0cbb43a4309781a27bd24bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6851574e1db70c89b626dc2c6ebd0146"><td class="memTemplParams" colspan="2">template&lt;typename LType , typename RType &gt; </td></tr>
<tr class="memitem:a6851574e1db70c89b626dc2c6ebd0146"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#a6851574e1db70c89b626dc2c6ebd0146">add_variant_t</a> = utilities::type_traits::variant::product_t&lt; <a class="el" href="namespacelibchemist_1_1tensor.html#a480b685722fd9de8442257ab458b180e">add_expr_t</a>, LType, RType &gt;</td></tr>
<tr class="memdesc:a6851574e1db70c89b626dc2c6ebd0146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef of a variant resulting from adding two variants together.  <a href="namespacelibchemist_1_1tensor.html#a6851574e1db70c89b626dc2c6ebd0146">More...</a><br /></td></tr>
<tr class="separator:a6851574e1db70c89b626dc2c6ebd0146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2ca2065baa70d4e9fb3f71d6b8c529"><td class="memTemplParams" colspan="2">template&lt;typename LType , typename RType &gt; </td></tr>
<tr class="memitem:a4f2ca2065baa70d4e9fb3f71d6b8c529"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#a4f2ca2065baa70d4e9fb3f71d6b8c529">subt_variant_t</a> = utilities::type_traits::variant::product_t&lt; <a class="el" href="namespacelibchemist_1_1tensor.html#a5e5e2028deb47d3c422f76a7fa70a3b4">subt_expr_t</a>, LType, RType &gt;</td></tr>
<tr class="memdesc:a4f2ca2065baa70d4e9fb3f71d6b8c529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef of a variant resulting from subtracting two variants.  <a href="namespacelibchemist_1_1tensor.html#a4f2ca2065baa70d4e9fb3f71d6b8c529">More...</a><br /></td></tr>
<tr class="separator:a4f2ca2065baa70d4e9fb3f71d6b8c529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5ac275cd37dce4aa8fcffad7beffc9"><td class="memTemplParams" colspan="2">template&lt;typename LType , typename RType &gt; </td></tr>
<tr class="memitem:a5a5ac275cd37dce4aa8fcffad7beffc9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#a5a5ac275cd37dce4aa8fcffad7beffc9">mult_variant_t</a> = utilities::type_traits::variant::product_t&lt; <a class="el" href="namespacelibchemist_1_1tensor.html#afafb390cd0cbb43a4309781a27bd24bf">mult_expr_t</a>, LType, RType &gt;</td></tr>
<tr class="memdesc:a5a5ac275cd37dce4aa8fcffad7beffc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef of a variant resulting from multiplying two variants together.  <a href="namespacelibchemist_1_1tensor.html#a5a5ac275cd37dce4aa8fcffad7beffc9">More...</a><br /></td></tr>
<tr class="separator:a5a5ac275cd37dce4aa8fcffad7beffc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22dba3e73038f864bc9b1897dc8e6ffb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22dba3e73038f864bc9b1897dc8e6ffb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#a22dba3e73038f864bc9b1897dc8e6ffb">variant_type_t</a> = typename <a class="el" href="structlibchemist_1_1tensor_1_1detail___1_1VariantType.html">detail_::VariantType</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a22dba3e73038f864bc9b1897dc8e6ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public API for determining the variant type of a <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a>.  <a href="namespacelibchemist_1_1tensor.html#a22dba3e73038f864bc9b1897dc8e6ffb">More...</a><br /></td></tr>
<tr class="separator:a22dba3e73038f864bc9b1897dc8e6ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0ff1fcf84ffae84617a2aa3fe53374b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#a0ff1fcf84ffae84617a2aa3fe53374b2">allclose</a> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;actual, const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;ref, double rtol=1.0E-5, double atol=1.0E-8)</td></tr>
<tr class="memdesc:a0ff1fcf84ffae84617a2aa3fe53374b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> instances for closeness.  <a href="namespacelibchemist_1_1tensor.html#a0ff1fcf84ffae84617a2aa3fe53374b2">More...</a><br /></td></tr>
<tr class="separator:a0ff1fcf84ffae84617a2aa3fe53374b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227ce7c75fed80fd320456648e302c75"><td class="memItemLeft" align="right" valign="top"><a id="a227ce7c75fed80fd320456648e302c75"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#a227ce7c75fed80fd320456648e302c75">allclose</a> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::ToTWrapper</a> &amp;actual, const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::ToTWrapper</a> &amp;ref, double rtol=1.0E-5, double atol=1.0E-8)</td></tr>
<tr class="memdesc:a227ce7c75fed80fd320456648e302c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as allclose except that the tensors are hierarchical. <br /></td></tr>
<tr class="separator:a227ce7c75fed80fd320456648e302c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae974615e052bcf1042a8de70fa6f41cc"><td class="memItemLeft" align="right" valign="top"><a id="ae974615e052bcf1042a8de70fa6f41cc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#ae974615e052bcf1042a8de70fa6f41cc">abs_allclose</a> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;actual, const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;ref, double rtol=1.0E-5, double atol=1.0E-8)</td></tr>
<tr class="memdesc:ae974615e052bcf1042a8de70fa6f41cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as allclose, except comparisons are done with unsigned elements. <br /></td></tr>
<tr class="separator:ae974615e052bcf1042a8de70fa6f41cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894e72c87711dc321c3b1d736beccdb2"><td class="memItemLeft" align="right" valign="top"><a id="a894e72c87711dc321c3b1d736beccdb2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#a894e72c87711dc321c3b1d736beccdb2">abs_allclose</a> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::ToTWrapper</a> &amp;actual, const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::ToTWrapper</a> &amp;ref, double rtol=1.0E-5, double atol=1.0E-8)</td></tr>
<tr class="memdesc:a894e72c87711dc321c3b1d736beccdb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as allclose except comparisons are done with unsigned elements. <br /></td></tr>
<tr class="separator:a894e72c87711dc321c3b1d736beccdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284c3d2cd4847b027ee47226f64508fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#a284c3d2cd4847b027ee47226f64508fd">apply_elementwise</a> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;input, const std::function&lt; double(double)&gt; &amp;fxn)</td></tr>
<tr class="memdesc:a284c3d2cd4847b027ee47226f64508fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new tensor by applying a function elementwise to an existing tensor.  <a href="namespacelibchemist_1_1tensor.html#a284c3d2cd4847b027ee47226f64508fd">More...</a><br /></td></tr>
<tr class="separator:a284c3d2cd4847b027ee47226f64508fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d77b9cf5add0a6dd1d93e1153031bd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#a7d77b9cf5add0a6dd1d93e1153031bd8">apply_elementwise_inplace</a> (<a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;input, const std::function&lt; void(double &amp;)&gt; &amp;fxn)</td></tr>
<tr class="memdesc:a7d77b9cf5add0a6dd1d93e1153031bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies an existing tensor by applying a function elementwise to its values.  <a href="namespacelibchemist_1_1tensor.html#a7d77b9cf5add0a6dd1d93e1153031bd8">More...</a><br /></td></tr>
<tr class="separator:a7d77b9cf5add0a6dd1d93e1153031bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08b38300a7935fe5bc915f9648da7a2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#ac08b38300a7935fe5bc915f9648da7a2">to_vector</a> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;t)</td></tr>
<tr class="memdesc:ac08b38300a7935fe5bc915f9648da7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens a tensor out into an std::vector.  <a href="namespacelibchemist_1_1tensor.html#ac08b38300a7935fe5bc915f9648da7a2">More...</a><br /></td></tr>
<tr class="separator:ac08b38300a7935fe5bc915f9648da7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1aa274af3bc1fb2788fd3af3cb06dbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#ac1aa274af3bc1fb2788fd3af3cb06dbb">concatenate</a> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;lhs, const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;rhs, std::size_t dim)</td></tr>
<tr class="memdesc:ac1aa274af3bc1fb2788fd3af3cb06dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatentaes two tensors together along the specified dimension.  <a href="namespacelibchemist_1_1tensor.html#ac1aa274af3bc1fb2788fd3af3cb06dbb">More...</a><br /></td></tr>
<tr class="separator:ac1aa274af3bc1fb2788fd3af3cb06dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbdbdb30463b380ddb0d35e9245bdd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::ToTWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#a0fbdbdb30463b380ddb0d35e9245bdd9">concatenate</a> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::ToTWrapper</a> &amp;lhs, const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::ToTWrapper</a> &amp;rhs, std::size_t dim)</td></tr>
<tr class="memdesc:a0fbdbdb30463b380ddb0d35e9245bdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two ToTs along the specified dimension.  <a href="namespacelibchemist_1_1tensor.html#a0fbdbdb30463b380ddb0d35e9245bdd9">More...</a><br /></td></tr>
<tr class="separator:a0fbdbdb30463b380ddb0d35e9245bdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcec8f687a6475382845cbf89e46372"><td class="memItemLeft" align="right" valign="top"><a id="aebcec8f687a6475382845cbf89e46372"></a>
<a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><b>grab_diagonal</b> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;t)</td></tr>
<tr class="separator:aebcec8f687a6475382845cbf89e46372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d0ddf292db739f022440ba924ec079"><td class="memItemLeft" align="right" valign="top"><a id="a25d0ddf292db739f022440ba924ec079"></a>
std::pair&lt; <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TWrapper</a>, <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TWrapper</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eigen_solve</b> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TWrapper</a> &amp;X)</td></tr>
<tr class="separator:a25d0ddf292db739f022440ba924ec079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd63f3c1b8d73736c1b71f9fa36e087"><td class="memItemLeft" align="right" valign="top"><a id="a2dd63f3c1b8d73736c1b71f9fa36e087"></a>
std::pair&lt; <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TWrapper</a>, <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TWrapper</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eigen_solve</b> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TWrapper</a> &amp;X, const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TWrapper</a> &amp;S)</td></tr>
<tr class="separator:a2dd63f3c1b8d73736c1b71f9fa36e087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6d8ffb1e2adebf611034f9bc242de9"><td class="memItemLeft" align="right" valign="top"><a id="abe6d8ffb1e2adebf611034f9bc242de9"></a>
<a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cholesky_linv</b> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TWrapper</a> &amp;M)</td></tr>
<tr class="separator:abe6d8ffb1e2adebf611034f9bc242de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affefab022fb453decf90abdf5e4fcb06"><td class="memItemLeft" align="right" valign="top"><a id="affefab022fb453decf90abdf5e4fcb06"></a>
<a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hmatrix_pow</b> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TWrapper</a> &amp;S, double pow)</td></tr>
<tr class="separator:affefab022fb453decf90abdf5e4fcb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d62997370aceceaa2fd09004d4bfd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#a68d62997370aceceaa2fd09004d4bfd2">remove_redundancy</a> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;C, const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;S, double thresh=1.0E-8)</td></tr>
<tr class="memdesc:a68d62997370aceceaa2fd09004d4bfd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elminates linear dependencies in the provided transformation.  <a href="namespacelibchemist_1_1tensor.html#a68d62997370aceceaa2fd09004d4bfd2">More...</a><br /></td></tr>
<tr class="separator:a68d62997370aceceaa2fd09004d4bfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04b7dfb176f5407dbbb4dfa572cd069"><td class="memTemplParams" colspan="2">template&lt;typename VariantType &gt; </td></tr>
<tr class="memitem:af04b7dfb176f5407dbbb4dfa572cd069"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1tensor_1_1Allocator.html">Allocator</a>&lt; VariantType &gt;::allocator_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibchemist_1_1tensor.html#af04b7dfb176f5407dbbb4dfa572cd069">default_allocator</a> ()</td></tr>
<tr class="memdesc:af04b7dfb176f5407dbbb4dfa572cd069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the process of creating a defaulted allocator.  <a href="namespacelibchemist_1_1tensor.html#af04b7dfb176f5407dbbb4dfa572cd069">More...</a><br /></td></tr>
<tr class="separator:af04b7dfb176f5407dbbb4dfa572cd069"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>tensor_wrapper.ipp </p>
<p>Inline implementations for the <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> class. This file should not be explicitly included in any other file aside from <a class="el" href="tensor__wrapper_8hpp_source.html">tensor_wrapper.hpp</a>. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a480b685722fd9de8442257ab458b180e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480b685722fd9de8442257ab458b180e">&#9670;&nbsp;</a></span>add_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LType , typename RType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelibchemist_1_1tensor.html#a480b685722fd9de8442257ab458b180e">libchemist::tensor::add_expr_t</a> = typedef decltype(std::declval&lt;LType&gt;() + std::declval&lt;RType&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the type that results from adding two tensors together. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LType</td><td>The type of the tensor on the left side of the plus sign </td></tr>
    <tr><td class="paramname">RType</td><td>The type of the tensor on the right side of the plus sign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6851574e1db70c89b626dc2c6ebd0146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6851574e1db70c89b626dc2c6ebd0146">&#9670;&nbsp;</a></span>add_variant_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LType , typename RType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelibchemist_1_1tensor.html#a6851574e1db70c89b626dc2c6ebd0146">libchemist::tensor::add_variant_t</a> = typedef utilities::type_traits::variant::product_t&lt;<a class="el" href="namespacelibchemist_1_1tensor.html#a480b685722fd9de8442257ab458b180e">add_expr_t</a>, LType, RType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef of a variant resulting from adding two variants together. </p>
<p>Given a std::variant with <code>n</code> types and a std::variant with <code>m</code> types this typedef defines an std::variant with <code>n*m</code> types. Thinking of the resulting std::variant as a row-major matrix, the <code>i,j</code>-th type is that resulting from adding the <code>i</code>-th type in <code>LType</code> with the <code>j</code>-th type in <code>RType</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LType</td><td>The variant on the left-side of the addition sign. </td></tr>
    <tr><td class="paramname">RType</td><td>The variant on the right-side of the addition sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a579a07e3c1f3659a44d4fd00d8e2a04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579a07e3c1f3659a44d4fd00d8e2a04d">&#9670;&nbsp;</a></span>enable_if_expression_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelibchemist_1_1tensor.html#a579a07e3c1f3659a44d4fd00d8e2a04d">libchemist::tensor::enable_if_expression_t</a> = typedef std::enable_if_t&lt;is_expression_v&lt;T&gt;, U&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to enable a function via SFINAE when <code>T</code> is part of the expression layer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>If <code>T</code> is part of the expression layer the decorated function will participate in overload resolution otherwise it will not. </td></tr>
    <tr><td class="paramname">U</td><td>The type that the typedef will be set to if <code>T</code> is part of the expression layer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee90ba7a7bc6dae8651be8089bd1f749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee90ba7a7bc6dae8651be8089bd1f749">&#9670;&nbsp;</a></span>labeled_variant_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorVariant &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelibchemist_1_1tensor.html#aee90ba7a7bc6dae8651be8089bd1f749">libchemist::tensor::labeled_variant_t</a> = typedef typename <a class="el" href="structlibchemist_1_1tensor_1_1detail___1_1LabeledVariant.html">detail_::LabeledVariant</a>&lt;TensorVariant&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public API for getting a variant of labeled tensors. </p>
<p>This is the public API for turning a variant of tensors into a variant of labeled tensors. For the i-th type in <code>TensorVariant</code> the i-th type in the resulting variant will be the type which results from calling <code>operator()(std::string)</code> on a tensor of that type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TensorVariant</td><td>A variant of tensors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afafb390cd0cbb43a4309781a27bd24bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afafb390cd0cbb43a4309781a27bd24bf">&#9670;&nbsp;</a></span>mult_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LType , typename RType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelibchemist_1_1tensor.html#afafb390cd0cbb43a4309781a27bd24bf">libchemist::tensor::mult_expr_t</a> = typedef decltype(std::declval&lt;LType&gt;() * std::declval&lt;RType&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the type that results from multiplying two tensors together. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LType</td><td>The type of the tensor on the left side of the times sign </td></tr>
    <tr><td class="paramname">RType</td><td>The type of the tensor on the right side of the times sign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a5ac275cd37dce4aa8fcffad7beffc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5ac275cd37dce4aa8fcffad7beffc9">&#9670;&nbsp;</a></span>mult_variant_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LType , typename RType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelibchemist_1_1tensor.html#a5a5ac275cd37dce4aa8fcffad7beffc9">libchemist::tensor::mult_variant_t</a> = typedef utilities::type_traits::variant::product_t&lt;<a class="el" href="namespacelibchemist_1_1tensor.html#afafb390cd0cbb43a4309781a27bd24bf">mult_expr_t</a>, LType, RType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef of a variant resulting from multiplying two variants together. </p>
<p>Given a std::variant with <code>n</code> types and a std::variant with <code>m</code> types this typedef defines an std::variant with <code>n*m</code> types. Thinking of the resulting std::variant as a row-major matrix, the <code>i,j</code>-th type is that resulting from multiplying the <code>i</code>-th type in <code>LType</code> with the <code>j</code>-th type in <code>RType</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LType</td><td>The variant on the left-side of the multiplication sign. </td></tr>
    <tr><td class="paramname">RType</td><td>The variant on the right-side of the multiplication sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e1310338e85cde7e70e25124cc7d4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1310338e85cde7e70e25124cc7d4f1">&#9670;&nbsp;</a></span>n_d_initializer_list_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelibchemist_1_1tensor.html#a6e1310338e85cde7e70e25124cc7d4f1">libchemist::tensor::n_d_initializer_list_t</a> = typedef typename <a class="el" href="structlibchemist_1_1tensor_1_1NDInitializerListTraits.html">NDInitializerListTraits</a>&lt;T, N&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience typedef of the initializer_list for a rank <code>N</code> tensor of scalars of type <code>T</code>. </p>
<p>This typedef is a typedef of the <code>type</code> member of the <code>NDInitializer&lt;T, N&gt;</code> type for coding convenience.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the scalars in the tensor. </td></tr>
    <tr><td class="paramname">N</td><td>The rank of the tensor we are generating the initializer_list for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e5e2028deb47d3c422f76a7fa70a3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5e2028deb47d3c422f76a7fa70a3b4">&#9670;&nbsp;</a></span>subt_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LType , typename RType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelibchemist_1_1tensor.html#a5e5e2028deb47d3c422f76a7fa70a3b4">libchemist::tensor::subt_expr_t</a> = typedef decltype(std::declval&lt;LType&gt;() - std::declval&lt;RType&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the type that results from subtracting two tensors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LType</td><td>The type of the tensor on the left side of the minus sign </td></tr>
    <tr><td class="paramname">RType</td><td>The type of the tensor on the right side of the minus sign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f2ca2065baa70d4e9fb3f71d6b8c529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2ca2065baa70d4e9fb3f71d6b8c529">&#9670;&nbsp;</a></span>subt_variant_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LType , typename RType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelibchemist_1_1tensor.html#a4f2ca2065baa70d4e9fb3f71d6b8c529">libchemist::tensor::subt_variant_t</a> = typedef utilities::type_traits::variant::product_t&lt;<a class="el" href="namespacelibchemist_1_1tensor.html#a5e5e2028deb47d3c422f76a7fa70a3b4">subt_expr_t</a>, LType, RType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef of a variant resulting from subtracting two variants. </p>
<p>Given a std::variant with <code>n</code> types and a std::variant with <code>m</code> types this typedef defines an std::variant with <code>n*m</code> types. Thinking of the resulting std::variant as a row-major matrix, the <code>i,j</code>-th type is that resulting from subtracting the <code>j</code>-th type in <code>RType</code> from the <code>i</code>-th type in <code>LType</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LType</td><td>The variant on the left-side of the minus sign. </td></tr>
    <tr><td class="paramname">RType</td><td>The variant on the right-side of the minus sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22dba3e73038f864bc9b1897dc8e6ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22dba3e73038f864bc9b1897dc8e6ffb">&#9670;&nbsp;</a></span>variant_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelibchemist_1_1tensor.html#a22dba3e73038f864bc9b1897dc8e6ffb">libchemist::tensor::variant_type_t</a> = typedef typename <a class="el" href="structlibchemist_1_1tensor_1_1detail___1_1VariantType.html">detail_::VariantType</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public API for determining the variant type of a <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a>. </p>
<p>This typedef is used to get the variant type of a <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> specialization. This typedef will fail to compile if <code>T</code> is not a specialization of <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A non-qualified <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0ff1fcf84ffae84617a2aa3fe53374b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff1fcf84ffae84617a2aa3fe53374b2">&#9670;&nbsp;</a></span>allclose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool libchemist::tensor::allclose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rtol</em> = <code>1.0E-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>atol</em> = <code>1.0E-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> instances for closeness. </p>
<p>This function will compare two tensors, <img class="formulaInl" alt="$A$" src="form_4.png"/> and <img class="formulaInl" alt="$B$" src="form_6.png"/>, elementwise and determine if all their values are close to one another. "Close" is defined by two parameters. The absolute tolerance, <code>atol</code>, defines the effective zero for all comparisons. If for a given index <img class="formulaInl" alt="$I$" src="form_55.png"/>, <img class="formulaInl" alt="$\mid A[I] - B[I]\mid$" src="form_59.png"/> two differs by less than <code>atol</code>, the difference is considered indistinguishable from zero and the elements the same. Particularly for very large elements achieving a difference on the order of <code>atol</code> is not always reasonable; in these cases, one cares more about the percent error. In this case <img class="formulaInl" alt="$\frac{\mid A[I] - B[I]\mid}{\mid B[I]\mid}$" src="form_57.png"/> must be less than a relative tolerance, <code>rtol</code>.</p>
<p>This function combines these criteria and returns true if <img class="formulaInl" alt="$A$" src="form_4.png"/> and <img class="formulaInl" alt="$B$" src="form_6.png"/> satisfy:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mid A - B\mid \le atol + rtol\mid B\mid \]" src="form_58.png"/>
</p>
<p>Note that this is <b>NOT</b> symmetric in <img class="formulaInl" alt="$A$" src="form_4.png"/> and <img class="formulaInl" alt="$B$" src="form_6.png"/>, but is commensurate with <img class="formulaInl" alt="$B$" src="form_6.png"/> being the reference (thereby dictating what is an acceptable relative tolerance).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actual</td><td>The tensor you computed and are comparing against a reference value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The tensor which <code>actual</code> is being compared to. Should be "the correct value". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rtol</td><td>The maximum percent error (as a decimal) allowed for any particular value. Assumed to be a positive decimal. Defaults to 1.0E-5, <em>i.e.</em>, 0.0001%. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">atol</td><td>The effective value of zero for comparisons. Assumed to be a positive decimal less than 1.0. Defaults to 1.0E-8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>actual</code> is "close" to <code>ref</code> and false otherwise. </dd></dl>

</div>
</div>
<a id="a284c3d2cd4847b027ee47226f64508fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284c3d2cd4847b027ee47226f64508fd">&#9670;&nbsp;</a></span>apply_elementwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> libchemist::tensor::apply_elementwise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; double(double)&gt; &amp;&#160;</td>
          <td class="paramname"><em>fxn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new tensor by applying a function elementwise to an existing tensor. </p>
<p>This function is a convenience function for creating a new tensor whose initial elements can be determined solely based on the element values of another tensor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The tensor supplying the input values <code>op</code> will be called with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The function to apply to each element of <code>input</code> to generate the resulting tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor having the same shape and distribution as <code>input</code>. The <img class="formulaInl" alt="$i$" src="form_12.png"/>-th element of the new tensor is the result of <code>op(input[i])</code>, where <code>input[i]</code> is the <img class="formulaInl" alt="$i$" src="form_12.png"/>-th element of <code>input</code>. </dd></dl>

</div>
</div>
<a id="a7d77b9cf5add0a6dd1d93e1153031bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d77b9cf5add0a6dd1d93e1153031bd8">&#9670;&nbsp;</a></span>apply_elementwise_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libchemist::tensor::apply_elementwise_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(double &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>fxn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies an existing tensor by applying a function elementwise to its values. </p>
<p>This function is a convenience function for modifying an existing tensor by an elementwise in-place operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The tensor supplying the input values to be changed in-place by <code>op</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The function to apply to each element of <code>input</code> to modify the values in-place. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1aa274af3bc1fb2788fd3af3cb06dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1aa274af3bc1fb2788fd3af3cb06dbb">&#9670;&nbsp;</a></span>concatenate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> libchemist::tensor::concatenate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatentaes two tensors together along the specified dimension. </p>
<p>This function joins two tensors together by making concatenating them together along the specified mode. For a rank <img class="formulaInl" alt="$N$" src="form_3.png"/> tensor, this means that the shape of the remaining N-1 modes must be identical.</p>
<dl class="section note"><dt>Note</dt><dd>Concatenation is in general non-commutative, i.e., <code>concatenate(A, B, dim)</code> will not necessarilly be the same as <code>concatenate(B, A, dim)</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The tensor which will serve as the base tensor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The tensor which will be added on to <code>lhs</code>. Must be the same rank as <code>lhs</code> and all modes aside from mode <code>dim</code> must have the same shape as the corresponding mode in <code>lhs</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>The 0-based offset indicating which mode of <code>lhs</code> and <code>rhs</code> will be concatenated. Must be in the range [0, rank(lhs)).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the shapes of the tensors are not compatible for the concatenation or if <code>dim</code> is not a valid mode offset. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fbdbdb30463b380ddb0d35e9245bdd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fbdbdb30463b380ddb0d35e9245bdd9">&#9670;&nbsp;</a></span>concatenate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::ToTWrapper</a> libchemist::tensor::concatenate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::ToTWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::ToTWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates two ToTs along the specified dimension. </p>
<p>This function is not yet implemented. </p>

</div>
</div>
<a id="af04b7dfb176f5407dbbb4dfa572cd069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04b7dfb176f5407dbbb4dfa572cd069">&#9670;&nbsp;</a></span>default_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VariantType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1tensor_1_1Allocator.html">Allocator</a>&lt;VariantType&gt;::allocator_ptr libchemist::tensor::default_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps the process of creating a defaulted allocator. </p>
<p>As more advanced alloctors are added to the library it will make sense to change the default <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> allocator. To decouple code from this choice, classes and functions needing a default_allocator instance are encouraged to get that allocator from this function.</p>
<dl class="section return"><dt>Returns</dt><dd>a type-erased, allocator.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if allocation fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68d62997370aceceaa2fd09004d4bfd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d62997370aceceaa2fd09004d4bfd2">&#9670;&nbsp;</a></span>remove_redundancy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> libchemist::tensor::remove_redundancy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>thresh</em> = <code>1.0E-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elminates linear dependencies in the provided transformation. </p>
<p>Given a matrix of column vectors, <code>C</code>, and their inner products, <code>S</code>, such that the inner product of vector <img class="formulaInl" alt="$i$" src="form_12.png"/> with vector <img class="formulaInl" alt="$j$" src="form_13.png"/> is given by <img class="formulaInl" alt="$S_{ij}$" src="form_62.png"/>. This function will return a new set of linearly-independent vectors by diagonalizing <code>S</code> and dropping vectors associated with eigen values below <code>thresh</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>A set of column vectors which may have some linear dependencies. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>The overlap of the column vectors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thresh</td><td>Vectors associated with eigen values below this value will be dropped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new, linearly-independent, vectors. </dd></dl>

</div>
</div>
<a id="ac08b38300a7935fe5bc915f9648da7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08b38300a7935fe5bc915f9648da7a2">&#9670;&nbsp;</a></span>to_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; libchemist::tensor::to_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">type::SparseTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens a tensor out into an std::vector. </p>
<p>This function will replicate the provided tensor (assuming it is distributed to begin with) and then flatten it into a vector. The flattening will occur in row-major format.</p>
<dl class="section note"><dt>Note</dt><dd>This function is primarily intended for use with low rank <code>t</code>, e.g. in taking actions based on the value of an eigenvalue. Direct access of high-rank tensors should be avoided.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The tensor to vectorize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tensor vectorized into an std::vector. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
