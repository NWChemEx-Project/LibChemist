<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libchemist: libchemist::tensor::TensorWrapper&lt; VariantType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libchemist
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibchemist.html">libchemist</a></li><li class="navelem"><a class="el" href="namespacelibchemist_1_1tensor.html">tensor</a></li><li class="navelem"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classlibchemist_1_1tensor_1_1TensorWrapper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libchemist::tensor::TensorWrapper&lt; VariantType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Fundamental type for wrapping tensors.  
 <a href="classlibchemist_1_1tensor_1_1TensorWrapper.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tensor__wrapper_8hpp_source.html">tensor_wrapper.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a53d7021e8991a01905141b4a40bf1f1a"><td class="memItemLeft" align="right" valign="top"><a id="a53d7021e8991a01905141b4a40bf1f1a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a53d7021e8991a01905141b4a40bf1f1a">variant_type</a> = VariantType</td></tr>
<tr class="memdesc:a53d7021e8991a01905141b4a40bf1f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the variant this wrapper is templated on. <br /></td></tr>
<tr class="separator:a53d7021e8991a01905141b4a40bf1f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271210570dccb4388898c5205b218002"><td class="memItemLeft" align="right" valign="top"><a id="a271210570dccb4388898c5205b218002"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_variant_type</b> = utilities::type_traits::variant::add_const_t&lt; <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a53d7021e8991a01905141b4a40bf1f1a">variant_type</a> &gt;</td></tr>
<tr class="separator:a271210570dccb4388898c5205b218002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba5dcfa77b247cc827131dc402b106b"><td class="memItemLeft" align="right" valign="top"><a id="acba5dcfa77b247cc827131dc402b106b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#acba5dcfa77b247cc827131dc402b106b">labeled_tensor_type</a> = <a class="el" href="classlibchemist_1_1tensor_1_1detail___1_1LabeledTensorWrapper.html">detail_::LabeledTensorWrapper</a>&lt; <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">my_type</a> &gt;</td></tr>
<tr class="memdesc:acba5dcfa77b247cc827131dc402b106b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a wrapper around a labeled tensor. <br /></td></tr>
<tr class="separator:acba5dcfa77b247cc827131dc402b106b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51c40dc532780de5c24e6eba0f17d3b"><td class="memItemLeft" align="right" valign="top"><a id="aa51c40dc532780de5c24e6eba0f17d3b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#aa51c40dc532780de5c24e6eba0f17d3b">const_labeled_tensor_type</a> = <a class="el" href="classlibchemist_1_1tensor_1_1detail___1_1LabeledTensorWrapper.html">detail_::LabeledTensorWrapper</a>&lt; const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">my_type</a> &gt;</td></tr>
<tr class="memdesc:aa51c40dc532780de5c24e6eba0f17d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a wrapper around a read-only labeled tensor. <br /></td></tr>
<tr class="separator:aa51c40dc532780de5c24e6eba0f17d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb08913e9cb2249210ff0ce84830213"><td class="memItemLeft" align="right" valign="top"><a id="aceb08913e9cb2249210ff0ce84830213"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#aceb08913e9cb2249210ff0ce84830213">annotation_type</a> = typename <a class="el" href="classlibchemist_1_1tensor_1_1detail___1_1LabeledTensorWrapper.html#ae830ede0fcf7c85474cccceab22c087d">labeled_tensor_type::annotation_type</a></td></tr>
<tr class="memdesc:aceb08913e9cb2249210ff0ce84830213"><td class="mdescLeft">&#160;</td><td class="mdescRight">String-like type used to annotate a tensor. <br /></td></tr>
<tr class="separator:aceb08913e9cb2249210ff0ce84830213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4b2b2f28435e5558fa9e1755eae970"><td class="memItemLeft" align="right" valign="top"><a id="a2c4b2b2f28435e5558fa9e1755eae970"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a2c4b2b2f28435e5558fa9e1755eae970">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a2c4b2b2f28435e5558fa9e1755eae970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for indexing and offsets. <br /></td></tr>
<tr class="separator:a2c4b2b2f28435e5558fa9e1755eae970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cee506f9e0a0cd7b0c27559b5ac1d0"><td class="memItemLeft" align="right" valign="top"><a id="a16cee506f9e0a0cd7b0c27559b5ac1d0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a16cee506f9e0a0cd7b0c27559b5ac1d0">extents_type</a> = std::vector&lt; <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a2c4b2b2f28435e5558fa9e1755eae970">size_type</a> &gt;</td></tr>
<tr class="memdesc:a16cee506f9e0a0cd7b0c27559b5ac1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for returning the extents. <br /></td></tr>
<tr class="separator:a16cee506f9e0a0cd7b0c27559b5ac1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e94ac4e7a758132e7f2f837b027e55"><td class="memItemLeft" align="right" valign="top"><a id="a82e94ac4e7a758132e7f2f837b027e55"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a82e94ac4e7a758132e7f2f837b027e55">allocator_ptr</a> = typename <a class="el" href="classlibchemist_1_1tensor_1_1Allocator.html">Allocator</a>&lt; <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a53d7021e8991a01905141b4a40bf1f1a">variant_type</a> &gt;::<a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a82e94ac4e7a758132e7f2f837b027e55">allocator_ptr</a></td></tr>
<tr class="memdesc:a82e94ac4e7a758132e7f2f837b027e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an allocator. <br /></td></tr>
<tr class="separator:a82e94ac4e7a758132e7f2f837b027e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e28b189f749447a3910a952dddfc28"><td class="memItemLeft" align="right" valign="top"><a id="a58e28b189f749447a3910a952dddfc28"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a58e28b189f749447a3910a952dddfc28">allocator_type</a> = typename allocator_ptr::element_type</td></tr>
<tr class="memdesc:a58e28b189f749447a3910a952dddfc28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erased type of the allocator. <br /></td></tr>
<tr class="separator:a58e28b189f749447a3910a952dddfc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2143bc33c7c6c7890e65af7b8cb59f"><td class="memItemLeft" align="right" valign="top"><a id="a1d2143bc33c7c6c7890e65af7b8cb59f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a1d2143bc33c7c6c7890e65af7b8cb59f">const_allocator_reference</a> = const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a58e28b189f749447a3910a952dddfc28">allocator_type</a> &amp;</td></tr>
<tr class="memdesc:a1d2143bc33c7c6c7890e65af7b8cb59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to a type-erased allocator. <br /></td></tr>
<tr class="separator:a1d2143bc33c7c6c7890e65af7b8cb59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6b9146abb4be7cbc853ee865f4cb58"><td class="memItemLeft" align="right" valign="top"><a id="aaf6b9146abb4be7cbc853ee865f4cb58"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>sparse_map_type</b> = <a class="el" href="classlibchemist_1_1sparse__map_1_1SparseMap_3_01ElementIndex_00_01ElementIndex_01_4.html">sparse_map::SparseMapEE</a></td></tr>
<tr class="separator:aaf6b9146abb4be7cbc853ee865f4cb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad8213d4260f8f0a378733380c37c442a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#ad8213d4260f8f0a378733380c37c442a">TensorWrapper</a> ()=default</td></tr>
<tr class="memdesc:ad8213d4260f8f0a378733380c37c442a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default CTor.  <a href="classlibchemist_1_1tensor_1_1TensorWrapper.html#ad8213d4260f8f0a378733380c37c442a">More...</a><br /></td></tr>
<tr class="separator:ad8213d4260f8f0a378733380c37c442a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd59562baf8cd4f4a5fa2b8656759b11"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#abd59562baf8cd4f4a5fa2b8656759b11">TensorWrapper</a> (<a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a82e94ac4e7a758132e7f2f837b027e55">allocator_ptr</a> p)</td></tr>
<tr class="memdesc:abd59562baf8cd4f4a5fa2b8656759b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> which will use the provided allocator to create its state.  <a href="classlibchemist_1_1tensor_1_1TensorWrapper.html#abd59562baf8cd4f4a5fa2b8656759b11">More...</a><br /></td></tr>
<tr class="separator:abd59562baf8cd4f4a5fa2b8656759b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26defd6a1f555a7d451b2cd6a84de7c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a26defd6a1f555a7d451b2cd6a84de7c8">TensorWrapper</a> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a16cee506f9e0a0cd7b0c27559b5ac1d0">extents_type</a> &amp;shape, <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a82e94ac4e7a758132e7f2f837b027e55">allocator_ptr</a> p=<a class="el" href="namespacelibchemist_1_1tensor.html#af04b7dfb176f5407dbbb4dfa572cd069">default_allocator</a>&lt; <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a53d7021e8991a01905141b4a40bf1f1a">variant_type</a> &gt;())</td></tr>
<tr class="memdesc:a26defd6a1f555a7d451b2cd6a84de7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> which wraps a tensor of the specified shape.  <a href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a26defd6a1f555a7d451b2cd6a84de7c8">More...</a><br /></td></tr>
<tr class="separator:a26defd6a1f555a7d451b2cd6a84de7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaaf8142d40f12f461a3614aebcdbb98"><td class="memTemplParams" colspan="2">template&lt;typename TensorType , typename  = eif_has_type&lt;std::decay_t&lt;TensorType&gt;&gt;&gt; </td></tr>
<tr class="memitem:abaaf8142d40f12f461a3614aebcdbb98"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#abaaf8142d40f12f461a3614aebcdbb98">TensorWrapper</a> (TensorType &amp;&amp;t, <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a82e94ac4e7a758132e7f2f837b027e55">allocator_ptr</a> p=<a class="el" href="namespacelibchemist_1_1tensor.html#af04b7dfb176f5407dbbb4dfa572cd069">default_allocator</a>&lt; <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a53d7021e8991a01905141b4a40bf1f1a">variant_type</a> &gt;())</td></tr>
<tr class="memdesc:abaaf8142d40f12f461a3614aebcdbb98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapping CTor.  <a href="classlibchemist_1_1tensor_1_1TensorWrapper.html#abaaf8142d40f12f461a3614aebcdbb98">More...</a><br /></td></tr>
<tr class="separator:abaaf8142d40f12f461a3614aebcdbb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52471336905403dade6c7654745b9e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#aa52471336905403dade6c7654745b9e3">TensorWrapper</a> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a> &amp;other)</td></tr>
<tr class="memdesc:aa52471336905403dade6c7654745b9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a copy of another <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a>.  <a href="classlibchemist_1_1tensor_1_1TensorWrapper.html#aa52471336905403dade6c7654745b9e3">More...</a><br /></td></tr>
<tr class="separator:aa52471336905403dade6c7654745b9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3592d25dfd646bf4407832ed6d071eaf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a3592d25dfd646bf4407832ed6d071eaf">TensorWrapper</a> (<a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a3592d25dfd646bf4407832ed6d071eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of another <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> instance.  <a href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a3592d25dfd646bf4407832ed6d071eaf">More...</a><br /></td></tr>
<tr class="separator:a3592d25dfd646bf4407832ed6d071eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf11fe19b23c4f657591e5521e876fe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#abf11fe19b23c4f657591e5521e876fe5">operator=</a> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a> &amp;rhs)</td></tr>
<tr class="memdesc:abf11fe19b23c4f657591e5521e876fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a copy of another <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> to this instance.  <a href="classlibchemist_1_1tensor_1_1TensorWrapper.html#abf11fe19b23c4f657591e5521e876fe5">More...</a><br /></td></tr>
<tr class="separator:abf11fe19b23c4f657591e5521e876fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5bdbb9941ed73f8acbde41f582e3ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a9d5bdbb9941ed73f8acbde41f582e3ba">operator=</a> (<a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a9d5bdbb9941ed73f8acbde41f582e3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of another <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> instance's state.  <a href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a9d5bdbb9941ed73f8acbde41f582e3ba">More...</a><br /></td></tr>
<tr class="separator:a9d5bdbb9941ed73f8acbde41f582e3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096671fb5f0ab142f9248c7d3e75baa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a1d2143bc33c7c6c7890e65af7b8cb59f">const_allocator_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a096671fb5f0ab142f9248c7d3e75baa9">allocator</a> () const</td></tr>
<tr class="memdesc:a096671fb5f0ab142f9248c7d3e75baa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator in a read-only state.  <a href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a096671fb5f0ab142f9248c7d3e75baa9">More...</a><br /></td></tr>
<tr class="separator:a096671fb5f0ab142f9248c7d3e75baa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a7a64d555d6286431eb1a39c828681"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a00a7a64d555d6286431eb1a39c828681">reallocate</a> (<a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a82e94ac4e7a758132e7f2f837b027e55">allocator_ptr</a> p)</td></tr>
<tr class="memdesc:a00a7a64d555d6286431eb1a39c828681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the allocator, reallocating the tensor (in place) if needed.  <a href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a00a7a64d555d6286431eb1a39c828681">More...</a><br /></td></tr>
<tr class="separator:a00a7a64d555d6286431eb1a39c828681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ae3c8c388c1e59540e3c32b44731d7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a15ae3c8c388c1e59540e3c32b44731d7">operator()</a> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#aceb08913e9cb2249210ff0ce84830213">annotation_type</a> &amp;annotation)</td></tr>
<tr class="memdesc:a15ae3c8c388c1e59540e3c32b44731d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotates the modes of the wrapped index with the provided labels.  <a href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a15ae3c8c388c1e59540e3c32b44731d7">More...</a><br /></td></tr>
<tr class="separator:a15ae3c8c388c1e59540e3c32b44731d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6008027e59d190eacd7857affe4c5c71"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a6008027e59d190eacd7857affe4c5c71">operator()</a> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#aceb08913e9cb2249210ff0ce84830213">annotation_type</a> &amp;annotation) const</td></tr>
<tr class="memdesc:a6008027e59d190eacd7857affe4c5c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotates the modes of the wrapped index with the provided labels.  <a href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a6008027e59d190eacd7857affe4c5c71">More...</a><br /></td></tr>
<tr class="separator:a6008027e59d190eacd7857affe4c5c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8116d8414ac0553ee8d435f19ffcfe"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a3c8116d8414ac0553ee8d435f19ffcfe">make_annotation</a> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#aceb08913e9cb2249210ff0ce84830213">annotation_type</a> &amp;letter=&quot;i&quot;) const</td></tr>
<tr class="memdesc:a3c8116d8414ac0553ee8d435f19ffcfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an annotation suitable for the wrapped tensor.  <a href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a3c8116d8414ac0553ee8d435f19ffcfe">More...</a><br /></td></tr>
<tr class="separator:a3c8116d8414ac0553ee8d435f19ffcfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61315c4b78c67007bffe2d0af01e962"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#af61315c4b78c67007bffe2d0af01e962">rank</a> () const</td></tr>
<tr class="memdesc:af61315c4b78c67007bffe2d0af01e962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of modes in the wrapped tensor.  <a href="classlibchemist_1_1tensor_1_1TensorWrapper.html#af61315c4b78c67007bffe2d0af01e962">More...</a><br /></td></tr>
<tr class="separator:af61315c4b78c67007bffe2d0af01e962"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a79cebb56ed090c90d7d3f8cc7a593695"><td class="memTemplParams" colspan="2">template&lt;typename VType &gt; </td></tr>
<tr class="memitem:a79cebb56ed090c90d7d3f8cc7a593695"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a79cebb56ed090c90d7d3f8cc7a593695">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a>&lt; VType &gt; &amp;t)</td></tr>
<tr class="memdesc:a79cebb56ed090c90d7d3f8cc7a593695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the wrapped tensor to the provided output stream.  <a href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a79cebb56ed090c90d7d3f8cc7a593695">More...</a><br /></td></tr>
<tr class="separator:a79cebb56ed090c90d7d3f8cc7a593695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1adad032956ea0c6218873027432ce3"><td class="memTemplParams" colspan="2">template&lt;typename LHSType , typename RHSType &gt; </td></tr>
<tr class="memitem:ae1adad032956ea0c6218873027432ce3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#ae1adad032956ea0c6218873027432ce3">operator!=</a> (const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a>&lt; LHSType &gt; &amp;lhs, const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a>&lt; RHSType &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae1adad032956ea0c6218873027432ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determiens if the wrapped tensor instances are different.  <a href="classlibchemist_1_1tensor_1_1TensorWrapper.html#ae1adad032956ea0c6218873027432ce3">More...</a><br /></td></tr>
<tr class="separator:ae1adad032956ea0c6218873027432ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename VariantType&gt;<br />
class libchemist::tensor::TensorWrapper&lt; VariantType &gt;</h3>

<p>Fundamental type for wrapping tensors. </p>
<p>Forward declare <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a>.</p>
<p>The <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> class is designed to provide a single type which can hold any of an array of tensor types. The types that it can hold are determined by the types in <code>VariantType</code>. Algorithms which take <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> instances, should do so only for a specific <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> specialization. In turn the algorithm signals to the user that the algorithm will work with all of the tensor types that the <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> specialization can hold. In turn, it becomes possible to write non-templated algorithms, which work with a variety of tensor types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VariantType</td><td>the type of the std::variant holding all possible tensor types the wrapper may hold. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad8213d4260f8f0a378733380c37c442a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8213d4260f8f0a378733380c37c442a">&#9670;&nbsp;</a></span>TensorWrapper() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VariantType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">libchemist::tensor::TensorWrapper</a>&lt; VariantType &gt;::<a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default CTor. </p>
<p>The <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> resulting from this ctor wraps no tensor, and has no allocator. At the moment the only way to make the resulting tensor into a useful tensor is by moving or assigning to it.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>Throws if the default ctor of any type in variant_type throws same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd59562baf8cd4f4a5fa2b8656759b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd59562baf8cd4f4a5fa2b8656759b11">&#9670;&nbsp;</a></span>TensorWrapper() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VariantType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">libchemist::tensor::TensorWrapper</a>&lt; VariantType &gt;::<a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a82e94ac4e7a758132e7f2f837b027e55">allocator_ptr</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> which will use the provided allocator to create its state. </p>
<p>This ctor allows you to set the allocator a <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> will use. The resulting <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> will have not contain an allocated tensor. At the moment the only way to have the resulting <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> wrap a useful tensor is to assign or move to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The allocator, passed as a pointer to the base, the tensor should use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>Throws if the default ctor of any type in the variant_type throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26defd6a1f555a7d451b2cd6a84de7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26defd6a1f555a7d451b2cd6a84de7c8">&#9670;&nbsp;</a></span>TensorWrapper() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VariantType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">libchemist::tensor::TensorWrapper</a>&lt; VariantType &gt;::<a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a16cee506f9e0a0cd7b0c27559b5ac1d0">extents_type</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a82e94ac4e7a758132e7f2f837b027e55">allocator_ptr</a>&#160;</td>
          <td class="paramname"><em>p</em> = <code><a class="el" href="namespacelibchemist_1_1tensor.html#af04b7dfb176f5407dbbb4dfa572cd069">default_allocator</a>&lt;&#160;<a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a53d7021e8991a01905141b4a40bf1f1a">variant_type</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> which wraps a tensor of the specified shape. </p>
<p>This ctor can be used to create a new tensor of the specified size. The underlying tensor is not yet initialized, and must be initialized before it is used. Attempting to use the tensor without initializing it, is likely to cause deadlock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>An r-element container such that the i-th element is the extent of the i-th mode of the resulting rank r tensor (r and i are zero based).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer to the allocator the tensor wrapper should use. By default the result of <code>default_allocator&lt;variant_type&gt;</code> is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>Throws if allocating the underlying tensor throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abaaf8142d40f12f461a3614aebcdbb98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaaf8142d40f12f461a3614aebcdbb98">&#9670;&nbsp;</a></span>TensorWrapper() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VariantType &gt; </div>
<div class="memtemplate">
template&lt;typename TensorType , typename  = eif_has_type&lt;std::decay_t&lt;TensorType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">libchemist::tensor::TensorWrapper</a>&lt; VariantType &gt;::<a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a> </td>
          <td>(</td>
          <td class="paramtype">TensorType &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a82e94ac4e7a758132e7f2f837b027e55">allocator_ptr</a>&#160;</td>
          <td class="paramname"><em>p</em> = <code><a class="el" href="namespacelibchemist_1_1tensor.html#af04b7dfb176f5407dbbb4dfa572cd069">default_allocator</a>&lt;&#160;<a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a53d7021e8991a01905141b4a40bf1f1a">variant_type</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapping CTor. </p>
<p>This constructor creates a new <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> instance which wraps the provided Tensor. After this call the <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> will either contain a copy of the provided tensor or it will have taken ownership of it depending on whether or not the tensor was moved into the <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TensorType</td><td>The type of the tensor we are wrapping. TensorType must be one of the types in <code>VariantType</code>. </td></tr>
    <tr><td class="paramname">&lt;anonymous&gt;</td><td>A type used to disable this ctor via SFINAE if <code>TensorType</code> is not present in <code>VariantType</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The tensor this <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> instance should wrap. <code>t</code> should be initialized and set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer to the allocator the tensor wrapper should use. By default the result of <code>default_allocator&lt;variant_type&gt;</code> is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa52471336905403dade6c7654745b9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52471336905403dade6c7654745b9e3">&#9670;&nbsp;</a></span>TensorWrapper() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VariantType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">libchemist::tensor::TensorWrapper</a>&lt; VariantType &gt;::<a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a>&lt; VariantType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a copy of another <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a>. </p>
<p>The exact semantics of the copy ctor are defined by the copy semantics of the wrapped tensor. The allocator however; will be deep-copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The instance we are copying. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3592d25dfd646bf4407832ed6d071eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3592d25dfd646bf4407832ed6d071eaf">&#9670;&nbsp;</a></span>TensorWrapper() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VariantType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">libchemist::tensor::TensorWrapper</a>&lt; VariantType &gt;::<a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a>&lt; VariantType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes ownership of another <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> instance. </p>
<p>The exact semantics of the move ctor are defined by the move semantics of the wrapped tensor. Ownership of the allocator in <code>other</code> will be transferred to this instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> we are transferring the state from. After this operation the state of <code>other</code> will in a valid, but otherwise undefined state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a096671fb5f0ab142f9248c7d3e75baa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096671fb5f0ab142f9248c7d3e75baa9">&#9670;&nbsp;</a></span>allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VariantType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a1d2143bc33c7c6c7890e65af7b8cb59f">const_allocator_reference</a> <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">libchemist::tensor::TensorWrapper</a>&lt; VariantType &gt;::allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the allocator in a read-only state. </p>
<p>This function can be used to retrieve the allocator that the <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> was initialized with. If the instance does not have an allocator an error will be thrown.</p>
<dl class="section return"><dt>Returns</dt><dd>The allocator used for the tensor.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the instance does not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c8116d8414ac0553ee8d435f19ffcfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8116d8414ac0553ee8d435f19ffcfe">&#9670;&nbsp;</a></span>make_annotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VariantType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">libchemist::tensor::TensorWrapper</a>&lt; VariantType &gt;::make_annotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#aceb08913e9cb2249210ff0ce84830213">annotation_type</a> &amp;&#160;</td>
          <td class="paramname"><em>letter</em> = <code>&quot;i&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an annotation suitable for the wrapped tensor. </p>
<p>For a rank <img class="formulaInl" alt="$r$" src="form_14.png"/> tensor this function will create a string containing <img class="formulaInl" alt="$r$" src="form_14.png"/> indices. The <img class="formulaInl" alt="$i$" src="form_12.png"/>-th 0-based mode's index will be the result of concatentating <code>letter</code> with <img class="formulaInl" alt="$i$" src="form_12.png"/>. For example, using the default value of <code>letter</code> this function will generate the annotation <code>"i0,i1,i2"</code> for a rank 3 tensor. If the wrapped tensor is a tensor-of-tensors, this function will insert a semicolon where appropriate.</p>
<p>This function is meant to be used to perform generic operations on the tensors by string replacement. For example:</p>
<div class="fragment"><div class="line"> <span class="keyword">auto</span> idx0 = t0.make_annotation();</div>
<div class="line"> <span class="keyword">auto</span> idx1 = t1.make_annotation(<span class="stringliteral">&quot;j&quot;</span>);</div>
<div class="line"> <span class="comment">// To contract mode 1 of t0 with mode 3 of t1 we</span></div>
<div class="line">replace <span class="stringliteral">&quot;j3&quot;</span> with <span class="stringliteral">&quot;i1&quot;</span> <span class="keyword">auto</span> new_idx1 =</div>
<div class="line">std::regex_replace(idx1, std::regex(<span class="stringliteral">&quot;j3&quot;</span>), <span class="stringliteral">&quot;i1&quot;</span>);</div>
<div class="line"> <span class="comment">// In practice we would work out the resulting</span></div>
<div class="line">annotation too <span class="keyword">auto</span> mult_op = t0(idx0) * t1(idx1);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">letter</td><td>The label part of the index. This is what will be concatenated with the mode number to get the final annotation for each mode. Default is <code>"i"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing an annotation which is appropriate for the tensor. </dd></dl>

</div>
</div>
<a id="a15ae3c8c388c1e59540e3c32b44731d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ae3c8c388c1e59540e3c32b44731d7">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VariantType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">libchemist::tensor::TensorWrapper</a>&lt; VariantType &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#aceb08913e9cb2249210ff0ce84830213">annotation_type</a> &amp;&#160;</td>
          <td class="paramname"><em>annotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Annotates the modes of the wrapped index with the provided labels. </p>
<p>The domain-specific language of tensor operations is written in terms of Einstein notation. This requires us to assign dummy indices to each mode of the tensor. This function pairs <code>annotation</code> with the wrapped tensor to provide a labeled tensor. The resulting labeled tensor can be used in tensor expressions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">annotation</td><td>The dummy indices we are annotating the underlying tensor with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A labeled read/write tensor. </dd></dl>

</div>
</div>
<a id="a6008027e59d190eacd7857affe4c5c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6008027e59d190eacd7857affe4c5c71">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VariantType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">libchemist::tensor::TensorWrapper</a>&lt; VariantType &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#aceb08913e9cb2249210ff0ce84830213">annotation_type</a> &amp;&#160;</td>
          <td class="paramname"><em>annotation</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Annotates the modes of the wrapped index with the provided labels. </p>
<p>The domain-specific language of tensor operations is written in terms of Einstein notation. This requires us to assign dummy indices to each mode of the tensor. This function pairs <code>annotation</code> with the wrapped tensor to provide a labeled tensor. The resulting labeled tensor can be used in tensor expressions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">annotation</td><td>The dummy indices we are annotating the underlying tensor with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A labeled read-only tensor. </dd></dl>

</div>
</div>
<a id="abf11fe19b23c4f657591e5521e876fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf11fe19b23c4f657591e5521e876fe5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VariantType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a>&amp; <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">libchemist::tensor::TensorWrapper</a>&lt; VariantType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a>&lt; VariantType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a copy of another <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> to this instance. </p>
<p>This operation will overwrite the current <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a>'s state with a copy of <code>rhs</code> 's state. The exact semantics of the copy will depend on copy assignment operator of the wrapped tensor in <code>rhs</code>. The allocator in <code>rhs</code> will be deep copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> instance we are copying the state from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> instance after overwriting its state with a copy of <code>rhs's</code> state. </dd></dl>

</div>
</div>
<a id="a9d5bdbb9941ed73f8acbde41f582e3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5bdbb9941ed73f8acbde41f582e3ba">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VariantType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a>&amp; <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">libchemist::tensor::TensorWrapper</a>&lt; VariantType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a>&lt; VariantType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes ownership of another <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> instance's state. </p>
<p>This operation will overwrite the current <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> instance's state with the state of <code>rhs</code>. The exact semantics of the move assignment will depend on the move assignment semantics of the wrapped tensor. The ownership of the allocator in <code>rhs</code> will be transferred to this instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>The <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> instance we are transferring the state from. After this operation <code>rhs</code> will be in a valid, but otherwise undefined state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> instance after overwriting its state with <code>rhs's</code> state. </dd></dl>

</div>
</div>
<a id="af61315c4b78c67007bffe2d0af01e962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61315c4b78c67007bffe2d0af01e962">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VariantType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">libchemist::tensor::TensorWrapper</a>&lt; VariantType &gt;::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of modes in the wrapped tensor. </p>
<p>For a normal, non-hierarchical tensor the rank is simply the number of modes in the tensor. For a hierarchical tensor the rank is still the number of modes in the tensor, but it should be noted that this is the sum of the number of independent and dependent modes.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of modes in the tensor. </dd></dl>

</div>
</div>
<a id="a00a7a64d555d6286431eb1a39c828681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a7a64d555d6286431eb1a39c828681">&#9670;&nbsp;</a></span>reallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VariantType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">libchemist::tensor::TensorWrapper</a>&lt; VariantType &gt;::reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html#a82e94ac4e7a758132e7f2f837b027e55">allocator_ptr</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the allocator, reallocating the tensor (in place) if needed. </p>
<p>Under most circumstances users of the <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> class shouldn't have to call this function. This function is mainly used under the hood when a reallocation needs to happen to make tensors compatible. It has public scope because it's useful for unit testing the effect different allocation strategies have. This operation is in place, and may mutate the underlying data (e.g., smaller tiles may result in small elements being set to hard zero) in addition to moving the data around in memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The new allocator for the tensor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ae1adad032956ea0c6218873027432ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1adad032956ea0c6218873027432ce3">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHSType , typename RHSType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a>&lt; LHSType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a>&lt; RHSType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determiens if the wrapped tensor instances are different. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHSType</td><td>The type of the variant in the left tensor wrapper. </td></tr>
    <tr><td class="paramname">RHSType</td><td>The type of the variant in the right tensor wrapper.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The wrapped tensor on the left of the not equal operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The wrapped tensor on the right of the not equal operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if <code>lhs</code> is equal to <code>rhs</code> and true otherwise. </dd></dl>

</div>
</div>
<a id="a79cebb56ed090c90d7d3f8cc7a593695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79cebb56ed090c90d7d3f8cc7a593695">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibchemist_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a>&lt; VType &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the wrapped tensor to the provided output stream. </p>
<p>This function is a convenience function for calling TensorWrapper::print so that the wrapped tensor can be printed in the usual C++ manner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">os</td><td>The stream we adding the string representation of the tensor to. After the call <code>os</code> will contain the string representation of the wrapped tensor instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The tensor to print to <code>os</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns <code>os</code> to facilitate operator chaining. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/libchemist/tensor/<a class="el" href="tensor__wrapper_8hpp_source.html">tensor_wrapper.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
